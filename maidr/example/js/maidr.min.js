class Constants {
  svg_container_id = 'svg-container';
  braille_container_id = 'braille-div';
  braille_input_id = 'braille-input';
  info_id = 'info';
  announcement_container_id = 'announcements';
  end_chime_id = 'end_chime';
  container_id = 'container';
  project_id = 'maidr';
  review_id_container = 'review_container';
  review_id = 'review';
  reviewSaveSpot;
  reviewSaveBrailleMode;
  constructor() {
    (this.svg_container = document.getElementById(this.svg_container_id)),
      (this.svg = document.querySelector(
        '#' + this.svg_container_id + ' > svg'
      )),
      (this.brailleContainer = document.getElementById(
        this.braille_container_id
      )),
      (this.brailleInput = document.getElementById(this.braille_input_id)),
      (this.infoDiv = document.getElementById(this.info_id)),
      (this.announceContainer = document.getElementById(
        this.announcement_container_id
      )),
      (this.nonMenuFocus = this.svg),
      (this.endChime = document.getElementById(this.end_chime_id));
  }
  minX = 0;
  maxX = 0;
  minY = 0;
  maxY = 0;
  plotId = '';
  chartType = '';
  navigation = 1;
  MAX_FREQUENCY = 1e3;
  MIN_FREQUENCY = 200;
  NULL_FREQUENCY = 100;
  MAX_SPEED = 2e3;
  MIN_SPEED = 50;
  INTERVAL = 50;
  vol = 0.5;
  MAX_VOL = 30;
  autoPlayRate = 250;
  colorSelected = '#03C809';
  brailleDisplayLength = 40;
  showRect = 1;
  hasRect = 1;
  duration = 0.3;
  outlierDuration = 0.06;
  autoPlayOutlierRate = 50;
  autoPlayPointsRate = 30;
  colorUnselected = '#595959';
  isTracking = 1;
  visualBraille = !1;
  showDisplay = 1;
  showDisplayInBraille = 1;
  showDisplayInAutoplay = 0;
  textMode = 'off';
  brailleMode = 'off';
  sonifMode = 'off';
  reviewMode = 'off';
  layer = 1;
  outlierInterval = null;
  isMac = navigator.userAgent.toLowerCase().includes('mac');
  control = this.isMac ? 'Cmd' : 'Ctrl';
  alt = this.isMac ? 'option' : 'Alt';
  home = this.isMac ? 'fn + Left arrow' : 'Home';
  end = this.isMac ? 'fn + Right arrow' : 'End';
  keypressInterval = 2e3;
  debugLevel = 3;
  canPlayEndChime = !1;
  manualData = !0;
  PrepChartHelperComponents() {
    document.getElementById(this.info_id) ||
      (document.getElementById(this.svg_container_id) &&
        document
          .getElementById(this.svg_container_id)
          .insertAdjacentHTML(
            'afterend',
            '<br>\n<div id="info" aria-live="assertive" aria-atomic="true">\n<p id="x"></p>\n<p id="y"></p>\n</div>\n'
          )),
      document.getElementById(this.announcement_container_id) ||
        (document.getElementById(this.info_id) &&
          document
            .getElementById(this.info_id)
            .insertAdjacentHTML(
              'afterend',
              '<div id="announcements" aria-live="assertive" aria-atomic="true">\n</div>\n'
            )),
      document.getElementById(this.braille_container_id) ||
        (document.getElementById(this.container_id) &&
          document
            .getElementById(this.container_id)
            .insertAdjacentHTML(
              'afterbegin',
              '<div id="braille-div">\n<input id="braille-input" class="braille-input hidden" type="text" />\n</div>\n'
            )),
      document.getElementById(this.svg_container_id) &&
        (document
          .querySelector('#' + this.svg_container_id + ' > svg')
          .setAttribute('role', 'application'),
        document
          .querySelector('#' + this.svg_container_id + ' > svg')
          .setAttribute('tabindex', '0')),
      document.getElementById(this.end_chime_id) ||
        (document.getElementById(this.info_id) &&
          document
            .getElementById(this.info_id)
            .insertAdjacentHTML(
              'afterend',
              '<div class="hidden"> <audio src="../src/terminalBell.mp3" id="end_chime"></audio> </div>'
            ));
  }
  KillAutoplay() {
    this.autoplayId &&
      (clearInterval(this.autoplayId), (this.autoplayId = null));
  }
  KillSepPlay() {
    this.sepPlayId && (clearInterval(this.sepPlayId), (this.sepPlayId = null));
  }
  SpeedUp() {
    constants.autoPlayRate - this.INTERVAL > this.MIN_SPEED &&
      (constants.autoPlayRate -= this.INTERVAL);
  }
  SpeedDown() {
    constants.autoPlayRate + this.INTERVAL <= this.MAX_SPEED &&
      (constants.autoPlayRate += this.INTERVAL);
  }
}
class Resources {
  constructor() {}
  language = 'en';
  knowledgeLevel = 'basic';
  strings = {
    en: {
      basic: {
        upper_outlier: 'Upper Outlier',
        lower_outlier: 'Lower Outlier',
        min: 'Minimum',
        max: 'Maximum',
        25: '25%',
        50: '50%',
        75: '75%',
        son_on: 'Sonification on',
        son_off: 'Sonification off',
        son_des: 'Sonification descrete',
        son_comp: 'Sonification compare',
        son_ch: 'Sonification chord',
        son_sep: 'Sonification separate',
        son_same: 'Sonification combined',
        empty: 'Empty',
      },
    },
  };
  GetString(t) {
    return this.strings[this.language][this.knowledgeLevel][t];
  }
}
class Menu {
  constructor() {
    this.CreateMenu(), this.LoadDataFromLocalStorage();
  }
  menuHtml = `
        <div id="menu" class="modal hidden" role="dialog" tabindex="-1">
            <div class="modal-dialog" role="document" tabindex="0">
                <div class="modal-content">
                    <div class="modal-header">
                        <h4 class="modal-title">Menu</h4>
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                            <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="modal-body">
                        <div>
                            <h5 class="modal-title">Keyboard Shortcuts</h5>
                            <table>
                                <caption class="sr-only">Keyboard Shortcuts</caption>
                                <thead>
                                    <tr>
                                        <th scope="col">Function</th>
                                        <th scope="col">Key</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Move around plot</td>
                                        <td>Arrow keys</td>
                                    </tr>
                                    <tr>
                                        <td>Go to the very left right up down</td>
                                        <td>${constants.control} + Arrow key</td>
                                    </tr>
                                    <tr>
                                        <td>Select the first element</td>
                                        <td>${constants.control} + ${constants.home}</td>
                                    </tr>
                                    <tr>
                                        <td>Select the last element</td>
                                        <td>${constants.control} + ${constants.end}</td>
                                    </tr>
                                    <tr>
                                        <td>Toggle Braille Mode</td>
                                        <td>b</td>
                                    </tr>
                                    <tr>
                                        <td>Toggle Sonification Mode</td>
                                        <td>s</td>
                                    </tr>
                                    <tr>
                                        <td>Toggle Text Mode</td>
                                        <td>t</td>
                                    </tr>
                                    <tr>
                                        <td>Repeat current sound</td>
                                        <td>Space</td>
                                    </tr>
                                    <tr>
                                        <td>Auto-play outward in direction of arrow</td>
                                        <td>${constants.control} + Shift + Arrow key</td>
                                    </tr>
                                    <tr>
                                        <td>Auto-play inward in direction of arrow</td>
                                        <td>${constants.alt} + Shift + Arrow key</td>
                                    </tr>
                                    <tr>
                                        <td>Stop Auto-play</td>
                                        <td>${constants.control}</td>
                                    </tr>
                                    <tr>
                                        <td>Auto-play speed up</td>
                                        <td>Period</td>
                                    </tr>
                                    <tr>
                                        <td>Auto-play speed down</td>
                                        <td>Comma</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <div>
                            <h5 class="modal-title">Settings</h5>
                            <p><input type="range" id="vol" name="vol" min="0" max="1" step=".05"><label for="vol">Volume</label></p>
                            <!-- <p><input type="checkbox" id="show_rect" name="show_rect"><label for="show_rect">Show Outline</label></p> //-->
                            <p><input type="number" min="4" max="2000" step="1" id="braille_display_length" name="braille_display_length"><label for="braille_display_length">Braille Display Size</label></p>
                            <p><input type="number" min="50" max="2000" step="50" id="autoplay_rate" name="autoplay_rate"><label for="autoplay_rate">Autoplay Rate</label></p>
                            <p><input type="color" id="color_selected" name="color_selected"><label for="color_selected">Outline Color</label></p>
                            <p><input type="number" min="10" max="2000" step="10" id="min_freq" name="min_freq"><label for="min_freq">Min Frequency (Hz)</label></p>
                            <p><input type="number" min="20" max="2010" step="10" id="max_freq" name="max_freq"><label for="max_freq">Max Frequency (Hz)</label></p>
                            <p><input type="number" min="500" max="5000" step="500" id="keypress_interval" name="keypress_interval"><label for="keypress_interval">Keypress Interval (ms)</label></p>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" id="save_and_close_menu">Save and close</button>
                        <button type="button" id="close_menu">Close</button>
                    </div>
                </div>
            </div>
        </div>
        <div id="modal_backdrop" class="modal-backdrop hidden"></div>
        `;
  CreateMenu() {
    document
      .querySelector('body')
      .insertAdjacentHTML('beforeend', this.menuHtml);
  }
  Toggle(t) {
    ((t =
      void 0 === t
        ? !!document.getElementById('menu').classList.contains('hidden')
        : t)
      ? (this.PopulateData(),
        document.getElementById('menu').classList.remove('hidden'),
        document.getElementById('modal_backdrop').classList.remove('hidden'),
        document.querySelector('#menu .close'))
      : (document.getElementById('menu').classList.add('hidden'),
        document.getElementById('modal_backdrop').classList.add('hidden'),
        constants.nonMenuFocus)
    ).focus();
  }
  PopulateData() {
    (document.getElementById('vol').value = constants.vol),
      (document.getElementById('autoplay_rate').value = constants.autoPlayRate),
      (document.getElementById('braille_display_length').value =
        constants.brailleDisplayLength),
      (document.getElementById('color_selected').value =
        constants.colorSelected),
      (document.getElementById('min_freq').value = constants.MIN_FREQUENCY),
      (document.getElementById('max_freq').value = constants.MAX_FREQUENCY),
      (document.getElementById('keypress_interval').value =
        constants.keypressInterval);
  }
  SaveData() {
    (constants.vol = document.getElementById('vol').value),
      (constants.autoPlayRate = document.getElementById('autoplay_rate').value),
      (constants.brailleDisplayLength = document.getElementById(
        'braille_display_length'
      ).value),
      (constants.colorSelected =
        document.getElementById('color_selected').value),
      (constants.MIN_FREQUENCY = document.getElementById('min_freq').value),
      (constants.MAX_FREQUENCY = document.getElementById('max_freq').value),
      (constants.keypressInterval =
        document.getElementById('keypress_interval').value);
  }
  SaveDataToLocalStorage() {
    var t = {};
    (t.vol = constants.vol),
      (t.autoPlayRate = constants.autoPlayRate),
      (t.brailleDisplayLength = constants.brailleDisplayLength),
      (t.colorSelected = constants.colorSelected),
      (t.MIN_FREQUENCY = constants.MIN_FREQUENCY),
      (t.MAX_FREQUENCY = constants.MAX_FREQUENCY),
      (t.keypressInterval = constants.keypressInterval),
      localStorage.setItem('settings_data', JSON.stringify(t));
  }
  LoadDataFromLocalStorage() {
    var t = JSON.parse(localStorage.getItem('settings_data'));
    t &&
      ((constants.vol = t.vol),
      (constants.autoPlayRate = t.autoPlayRate),
      (constants.brailleDisplayLength = t.brailleDisplayLength),
      (constants.colorSelected = t.colorSelected),
      (constants.MIN_FREQUENCY = t.MIN_FREQUENCY),
      (constants.MAX_FREQUENCY = t.MAX_FREQUENCY),
      (constants.keypressInterval = t.keypressInterval));
  }
}
class Position {
  constructor(t, e, n = -1) {
    (this.x = t), (this.y = e), (this.z = n);
  }
}
class Helper {
  static containsObject(e, n) {
    for (let t = 0; t < n.length; t++) if (n[t] === e) return !0;
    return !1;
  }
}
class Tracker {
  constructor() {
    this.DataSetup();
  }
  DataSetup() {
    var t;
    this.GetTrackerData() ||
      (((t = {}).userAgent = Object.assign(navigator.userAgent)),
      (t.vendor = Object.assign(navigator.vendor)),
      (t.language = Object.assign(navigator.language)),
      (t.platform = Object.assign(navigator.platform)),
      (t.events = []),
      this.SaveTrackerData(t));
  }
  DownloadTrackerData() {
    var t = document.createElement('a'),
      e = this.GetTrackerData(),
      e = new Blob([JSON.stringify(e)], { type: 'text/plain' });
    (t.href = URL.createObjectURL(e)),
      (t.download = 'tracking.json'),
      t.click();
  }
  SaveTrackerData(t) {
    localStorage.setItem(constants.project_id, JSON.stringify(t));
  }
  GetTrackerData() {
    return JSON.parse(localStorage.getItem(constants.project_id));
  }
  Delete() {
    localStorage.removeItem(constants.project_id),
      (this.data = null),
      0 < constants.debugLevel && console.log('tracking data cleared'),
      this.DataSetup();
  }
  LogEvent(t) {
    var e,
      n = {};
    if (
      ((n.timestamp = Object.assign(t.timeStamp)),
      (n.time = Date().toString()),
      (n.key = Object.assign(t.key)),
      (n.which = Object.assign(t.which)),
      (n.altKey = Object.assign(t.altKey)),
      (n.ctrlKey = Object.assign(t.ctrlKey)),
      (n.shiftKey = Object.assign(t.shiftKey)),
      t.path && (n.focus = Object.assign(t.path[0].tagName)),
      this.isUndefinedOrNull(constants.position) ||
        (n.position = Object.assign(constants.position)),
      this.isUndefinedOrNull(constants.minX) ||
        (n.min_x = Object.assign(constants.minX)),
      this.isUndefinedOrNull(constants.maxX) ||
        (n.max_x = Object.assign(constants.maxX)),
      this.isUndefinedOrNull(constants.minY) ||
        (n.min_y = Object.assign(constants.minY)),
      this.isUndefinedOrNull(constants.MAX_FREQUENCY) ||
        (n.max_frequency = Object.assign(constants.MAX_FREQUENCY)),
      this.isUndefinedOrNull(constants.MIN_FREQUENCY) ||
        (n.min_frequency = Object.assign(constants.MIN_FREQUENCY)),
      this.isUndefinedOrNull(constants.NULL_FREQUENCY) ||
        (n.null_frequency = Object.assign(constants.NULL_FREQUENCY)),
      this.isUndefinedOrNull(constants.MAX_SPEED) ||
        (n.max_speed = Object.assign(constants.MAX_SPEED)),
      this.isUndefinedOrNull(constants.MIN_SPEED) ||
        (n.min_speed = Object.assign(constants.MIN_SPEED)),
      this.isUndefinedOrNull(constants.INTERVAL) ||
        (n.interval = Object.assign(constants.INTERVAL)),
      this.isUndefinedOrNull(constants.vol) ||
        (n.volume = Object.assign(constants.vol)),
      this.isUndefinedOrNull(constants.autoPlayRate) ||
        (n.autoplay_rate = Object.assign(constants.autoPlayRate)),
      this.isUndefinedOrNull(constants.colorSelected) ||
        (n.color = Object.assign(constants.colorSelected)),
      this.isUndefinedOrNull(constants.brailleDisplayLength) ||
        (n.braille_display_length = Object.assign(
          constants.brailleDisplayLength
        )),
      this.isUndefinedOrNull(constants.duration) ||
        (n.tone_duration = Object.assign(constants.duration)),
      this.isUndefinedOrNull(constants.autoPlayOutlierRate) ||
        (n.autoplay_outlier_rate = Object.assign(
          constants.autoPlayOutlierRate
        )),
      this.isUndefinedOrNull(constants.autoPlayPointsRate) ||
        (n.autoplay_points_rate = Object.assign(constants.autoPlayPointsRate)),
      this.isUndefinedOrNull(constants.textMode) ||
        (n.text_mode = Object.assign(constants.textMode)),
      this.isUndefinedOrNull(constants.sonifMode) ||
        (n.sonification_mode = Object.assign(constants.sonifMode)),
      this.isUndefinedOrNull(constants.brailleMode) ||
        (n.braille_mode = Object.assign(constants.brailleMode)),
      this.isUndefinedOrNull(constants.layer) ||
        (n.layer = Object.assign(constants.layer)),
      this.isUndefinedOrNull(constants.chartType) ||
        (n.chart_type = Object.assign(constants.chartType)),
      !this.isUndefinedOrNull(constants.infoDiv.innerHTML))
    ) {
      let t = Object.assign(constants.infoDiv.innerHTML);
      (t = t.replaceAll(/<[^>]*>?/gm, '')), (n.text_display = t);
    }
    this.isUndefinedOrNull(location.href) ||
      (n.location = Object.assign(location.href));
    let o = '',
      s = '',
      i = '',
      a = '',
      l = '',
      r = '';
    'barplot' == constants.chartType
      ? (this.isUndefinedOrNull(plot.columnLabels[position.x]) ||
          (o = plot.columnLabels[position.x]),
        this.isUndefinedOrNull(plot.plotLegend.x) || (i = plot.plotLegend.x),
        this.isUndefinedOrNull(plot.plotLegend.y) || (a = plot.plotLegend.y),
        this.isUndefinedOrNull(plot.plotData[position.x]) ||
          (l = plot.plotData[position.x]))
      : 'heatmap' == constants.chartType
      ? (this.isUndefinedOrNull(plot.x_labels[position.x]) ||
          (o = plot.x_labels[position.x].trim()),
        this.isUndefinedOrNull(plot.y_labels[position.y]) ||
          (s = plot.y_labels[position.y].trim()),
        this.isUndefinedOrNull(plot.x_group_label) || (i = plot.x_group_label),
        this.isUndefinedOrNull(plot.y_group_label) || (a = plot.y_group_label),
        this.isUndefinedOrNull(plot.values) ||
          this.isUndefinedOrNull(plot.values[position.x][position.y]) ||
          (l = plot.values[position.x][position.y]),
        this.isUndefinedOrNull(plot.group_labels[2]) ||
          (r = plot.group_labels[2]))
      : 'boxplot' == constants.chartType
      ? ((t = 'vert' == constants.plotOrientation ? position.x : position.y),
        (e = 'vert' == constants.plotOrientation ? position.y : position.x),
        this.isUndefinedOrNull(plot.x_group_label) || (i = plot.x_group_label),
        this.isUndefinedOrNull(plot.y_group_label) || (a = plot.y_group_label),
        'vert' == constants.plotOrientation
          ? -1 < t &&
            -1 < e &&
            (this.isUndefinedOrNull(plot.plotData[t][e].label) ||
              (s = plot.plotData[t][e].label),
            this.isUndefinedOrNull(plot.x_labels[position.x]) ||
              (o = plot.x_labels[position.x]),
            this.isUndefinedOrNull(plot.plotData[t][e].values)
              ? this.isUndefinedOrNull(plot.plotData[t][e].y) ||
                (l = plot.plotData[t][e].y)
              : (l = plot.plotData[t][e].values))
          : -1 < t &&
            -1 < e &&
            (this.isUndefinedOrNull(plot.plotData[t][e].label) ||
              (o = plot.plotData[t][e].label),
            this.isUndefinedOrNull(plot.y_labels[position.y]) ||
              (s = plot.y_labels[position.y]),
            this.isUndefinedOrNull(plot.plotData[t][e].values)
              ? this.isUndefinedOrNull(plot.plotData[t][e].x) ||
                (l = plot.plotData[t][e].x)
              : (l = plot.plotData[t][e].values)))
      : 'scatterplot' == constants.chartType &&
        (this.isUndefinedOrNull(plot.x_group_label) || (i = plot.x_group_label),
        this.isUndefinedOrNull(plot.y_group_label) || (a = plot.y_group_label),
        this.isUndefinedOrNull(plot.x[position.x]) || (o = plot.x[position.x]),
        this.isUndefinedOrNull(plot.y[position.x]) || (s = plot.y[position.x]),
        (l = [o, s])),
      (n.x_tickmark = Object.assign(o)),
      (n.y_tickmark = Object.assign(s)),
      (n.x_label = Object.assign(i)),
      (n.y_label = Object.assign(a)),
      (n.value = Object.assign(l)),
      (n.fill_value = Object.assign(r));
    t = this.GetTrackerData();
    t.events.push(n), this.SaveTrackerData(t);
  }
  isUndefinedOrNull(t) {
    try {
      return null == t;
    } catch {
      return !0;
    }
  }
}
class Review {
  constructor() {
    document.getElementById(constants.review_id) ||
      (document.getElementById(constants.info_id) &&
        document
          .getElementById(constants.info_id)
          .insertAdjacentHTML(
            'beforebegin',
            '<div id="' +
              constants.review_id_container +
              '" class="hidden sr-only sr-only-focusable"><input id="' +
              constants.review_id +
              '" type="text" readonly size="50" /></div>'
          )),
      constants &&
        ((constants.review_container = document.querySelector(
          '#' + constants.review_id_container
        )),
        (constants.review = document.querySelector('#' + constants.review_id)));
  }
  ToggleReviewMode(t = !0) {
    t
      ? ((constants.reviewSaveSpot = document.activeElement),
        constants.review_container.classList.remove('hidden'),
        (constants.reviewSaveBrailleMode = constants.brailleMode),
        constants.review.focus(),
        display.announceText('Review on'))
      : (constants.review_container.classList.add('hidden'),
        'on' == constants.reviewSaveBrailleMode
          ? display.toggleBrailleMode('on')
          : constants.reviewSaveSpot.focus(),
        display.announceText('Review off'));
  }
}
class Audio {
  constructor() {
    (this.AudioContext = window.AudioContext || window.webkitAudioContext),
      (this.audioContext = new AudioContext()),
      (this.compressor = this.compressorSetup(this.audioContext));
  }
  compressorSetup() {
    var t = this.audioContext.createDynamicsCompressor(),
      e =
        ((t.threshold.value = -50),
        (t.knee.value = 40),
        (t.ratio.value = 12),
        (t.attack.value = 0),
        (t.release.value = 0.25),
        this.audioContext.createGain());
    return (
      (e.gain.value = constants.vol),
      t.connect(e),
      e.connect(this.audioContext.destination),
      t
    );
  }
  playTone() {
    let t = constants.duration,
      e = constants.vol,
      n = 0,
      o = 0,
      s = 0,
      i = 0;
    var a, l;
    'barplot' == constants.chartType
      ? ((o = plot.plotData[position.x]),
        (n = position.x),
        (s = this.SlideBetween(
          o,
          constants.minY,
          constants.maxY,
          constants.MIN_FREQUENCY,
          constants.MAX_FREQUENCY
        )),
        (i = this.SlideBetween(n, constants.minX, constants.maxX, -1, 1)))
      : 'boxplot' == constants.chartType
      ? ((l = 'vert' == constants.plotOrientation ? position.x : position.y),
        (a = 'vert' == constants.plotOrientation ? position.y : position.x),
        (o =
          -1 < position.z && Object.hasOwn(plot.plotData[l][a], 'values')
            ? plot.plotData[l][a].values[position.z]
            : 'vert' == constants.plotOrientation
            ? plot.plotData[l][a].y
            : plot.plotData[l][a].x),
        (i =
          'blank' != plot.plotData[l][a].type
            ? 'vert' == constants.plotOrientation
              ? ((s = this.SlideBetween(
                  o,
                  constants.minY,
                  constants.maxY,
                  constants.MIN_FREQUENCY,
                  constants.MAX_FREQUENCY
                )),
                this.SlideBetween(o, constants.minY, constants.maxY, -1, 1))
              : ((s = this.SlideBetween(
                  o,
                  constants.minX,
                  constants.maxX,
                  constants.MIN_FREQUENCY,
                  constants.MAX_FREQUENCY
                )),
                this.SlideBetween(o, constants.minX, constants.maxX, -1, 1))
            : ((s = constants.MIN_FREQUENCY), 0)))
      : 'heatmap' == constants.chartType
      ? ((o = plot.values[position.y][position.x]),
        (n = position.x),
        (s = this.SlideBetween(
          o,
          constants.minY,
          constants.maxY,
          constants.MIN_FREQUENCY,
          constants.MAX_FREQUENCY
        )),
        (i = this.SlideBetween(n, constants.minX, constants.maxX, -1, 1)))
      : 'scatterplot' == constants.chartType &&
        (1 == constants.layer
          ? ((o = plot.y[position.x][position.z]),
            (e =
              1 == plot.max_count
                ? constants.vol
                : this.SlideBetween(
                    plot.points_count[position.x][position.z],
                    1,
                    plot.max_count,
                    constants.vol,
                    constants.MAX_VOL
                  )),
            (n = position.x),
            (s = this.SlideBetween(
              o,
              constants.minY,
              constants.maxY,
              constants.MIN_FREQUENCY,
              constants.MAX_FREQUENCY
            )),
            (i = this.SlideBetween(n, constants.minX, constants.maxX, -1, 1)))
          : 2 == constants.layer &&
            ((o = plot.curvePoints[positionL1.x]),
            (n = positionL1.x),
            (s = this.SlideBetween(
              o,
              plot.curveMinY,
              plot.curveMaxY,
              constants.MIN_FREQUENCY,
              constants.MAX_FREQUENCY
            )),
            (i = this.SlideBetween(n, constants.minX, constants.maxX, -1, 1)))),
      5 < constants.debugLevel &&
        (console.log('will play tone at freq', s),
        'boxplot' == constants.chartType
          ? console.log(
              'based on',
              constants.minY,
              '<',
              o,
              '<',
              constants.maxY,
              ' | freq min',
              constants.MIN_FREQUENCY,
              'max',
              constants.MAX_FREQUENCY
            )
          : console.log(
              'based on',
              constants.minX,
              '<',
              o,
              '<',
              constants.maxX,
              ' | freq min',
              constants.MIN_FREQUENCY,
              'max',
              constants.MAX_FREQUENCY
            )),
      'boxplot' == constants.chartType &&
        ((l = 'vert' == constants.plotOrientation ? position.x : position.y),
        (a = 'vert' == constants.plotOrientation ? position.y : position.x),
        'outlier' == plot.plotData[l][a].type) &&
        (t = constants.outlierDuration),
      this.playOscillator(s, t, i, e, 'sine'),
      'boxplot' == constants.chartType
        ? ((l = 'vert' == constants.plotOrientation ? position.x : position.y),
          (a = 'vert' == constants.plotOrientation ? position.y : position.x),
          'range' == plot.plotData[l][a].type &&
            ((l = s / 2),
            this.playOscillator(l, t, i, constants.vol / 4, 'triangle')))
        : 'heatmap' == constants.chartType && 0 == o && this.PlayNull();
  }
  playOscillator(t, e, n, o = 1, s = 'sine') {
    var i = this.audioContext.currentTime;
    const a = this.audioContext.createOscillator(),
      l =
        ((a.type = s),
        (a.frequency.value = parseFloat(t)),
        a.start(),
        this.audioContext.createGain());
    l.gain.setValueCurveAtTime(
      [0.5 * o, +o, 0.5 * o, 0.5 * o, 0.5 * o, 0.1 * o, 1e-4 * o],
      i,
      e
    );
    const r = new PannerNode(this.audioContext, {
      panningModel: 'HRTF',
      distanceModel: 'linear',
      positionX: position.x,
      positionY: position.y,
      positionZ: 1,
      plotOrientationX: 0,
      plotOrientationY: 0,
      plotOrientationZ: -1,
      refDistance: 1,
      maxDistance: 1e4,
      rolloffFactor: 10,
      coneInnerAngle: 40,
      coneOuterAngle: 50,
      coneOuterGain: 0.4,
    });
    s = this.audioContext.createStereoPanner();
    (s.pan.value = n),
      a.connect(l),
      l.connect(s),
      s.connect(r),
      r.connect(this.compressor),
      setTimeout(() => {
        r.disconnect(), l.disconnect(), a.stop(), a.disconnect();
      }, 1e3 * e * 2);
  }
  playSmooth(
    t = [600, 500, 400, 300],
    e = 2,
    n = [-1, 0, 1],
    o = 1,
    s = 'sine'
  ) {
    var i = new Array(3 * t.length).fill(0.5 * o),
      o = (i.push(1e-4 * o), this.audioContext.currentTime);
    const a = this.audioContext.createOscillator();
    (a.type = s),
      a.frequency.setValueCurveAtTime(t, o, e),
      a.start(),
      (constants.isSmoothAutoplay = !0),
      (this.smoothGain = this.audioContext.createGain()),
      this.smoothGain.gain.setValueCurveAtTime(i, o, e);
    const l = new PannerNode(this.audioContext, {
      panningModel: 'HRTF',
      distanceModel: 'linear',
      positionX: position.x,
      positionY: position.y,
      positionZ: 1,
      plotOrientationX: 0,
      plotOrientationY: 0,
      plotOrientationZ: -1,
      refDistance: 1,
      maxDistance: 1e4,
      rolloffFactor: 10,
      coneInnerAngle: 40,
      coneOuterAngle: 50,
      coneOuterGain: 0.4,
    });
    s = this.audioContext.createStereoPanner();
    s.pan.setValueCurveAtTime(n, o, e),
      a.connect(this.smoothGain),
      this.smoothGain.connect(s),
      s.connect(l),
      l.connect(this.compressor),
      (constants.smoothId = setTimeout(() => {
        l.disconnect(),
          this.smoothGain.disconnect(),
          a.stop(),
          a.disconnect(),
          (constants.isSmoothAutoplay = !1);
      }, 1e3 * e * 2));
  }
  PlayNull() {
    console.log('playing null');
    let e = constants.NULL_FREQUENCY,
      n = constants.duration,
      o = constants.vol,
      s = 'triangle';
    this.playOscillator(e, n, 0, o, s),
      setTimeout(
        function (t) {
          t.playOscillator((23 * e) / 24, n, 0, o, s);
        },
        Math.round((n / 5) * 1e3),
        this
      );
  }
  playEnd() {
    if (constants.canPlayEndChime) {
      let t = constants.endChime.cloneNode(!0);
      t.play(), (t = null);
    }
  }
  KillSmooth() {
    constants.smoothId &&
      (this.smoothGain.gain.cancelScheduledValues(0),
      this.smoothGain.gain.exponentialRampToValueAtTime(
        1e-4,
        this.audioContext.currentTime + 0.03
      ),
      clearTimeout(constants.smoothId),
      (constants.isSmoothAutoplay = !1));
  }
  SlideBetween(t, e, n, o, s) {
    return ((t - e) / (n - e)) * (s - o) + o;
  }
}
class Display {
  constructor() {
    (this.infoDiv = constants.infoDiv),
      (this.x = {}),
      (this.x.id = 'x'),
      (this.x.textBase = 'x-value: '),
      (this.y = {}),
      (this.y.id = 'y'),
      (this.y.textBase = 'y-value: '),
      (this.boxplotGridPlaceholders = [
        resources.GetString('lower_outlier'),
        resources.GetString('min'),
        resources.GetString('25'),
        resources.GetString('50'),
        resources.GetString('75'),
        resources.GetString('max'),
        resources.GetString('upper_outlier'),
      ]);
  }
  toggleTextMode() {
    'off' == constants.textMode
      ? (constants.textMode = 'terse')
      : 'terse' == constants.textMode
      ? (constants.textMode = 'verbose')
      : 'verbose' == constants.textMode && (constants.textMode = 'off'),
      this.announceText(
        '<span aria-hidden="true">Text mode:</span> ' + constants.textMode
      );
  }
  toggleBrailleMode(t) {
    'scatterplot' == constants.chartType && 1 == constants.layer
      ? this.announceText('Braille is not supported in point layer.')
      : ('on' ==
        (t = void 0 === t ? ('on' == constants.brailleMode ? 'off' : 'on') : t)
          ? ('boxplot' == constants.chartType &&
              ('vert' != constants.plotOrientation &&
              -1 == position.x &&
              position.y == plot.plotData.length
                ? ((position.x += 1), --position.y)
                : 'vert' == constants.plotOrientation &&
                  0 == position.x &&
                  (position.y, plot.plotData[0].length)),
            (constants.brailleMode = 'on'),
            constants.brailleInput.classList.remove('hidden'),
            constants.brailleInput.focus(),
            constants.brailleInput.setSelectionRange(position.x, position.x),
            this.SetBraille(plot),
            'heatmap' == constants.chartType &&
              ((t = position.y * (plot.num_cols + 1) + position.x),
              constants.brailleInput.setSelectionRange(t, t)),
            -1 == position.x &&
              -1 == position.y &&
              constants.brailleInput.setSelectionRange(0, 0))
          : ((constants.brailleMode = 'off'),
            constants.brailleInput.classList.add('hidden'),
            (!constants.review_container ||
            constants.review_container.classList.contains('hidden')
              ? constants.svg
              : constants.review
            ).focus()),
        this.announceText('Braille ' + constants.brailleMode));
  }
  toggleSonificationMode() {
    'scatterplot' == constants.chartType && 1 == constants.layer
      ? 'off' == constants.sonifMode
        ? ((constants.sonifMode = 'sep'),
          this.announceText(resources.GetString('son_sep')))
        : 'sep' == constants.sonifMode
        ? ((constants.sonifMode = 'same'),
          this.announceText(resources.GetString('son_same')))
        : 'same' == constants.sonifMode &&
          ((constants.sonifMode = 'off'),
          this.announceText(resources.GetString('son_off')))
      : 'off' == constants.sonifMode
      ? ((constants.sonifMode = 'on'),
        this.announceText(resources.GetString('son_on')))
      : ((constants.sonifMode = 'off'),
        this.announceText(resources.GetString('son_off')));
  }
  toggleLayerMode() {
    1 == constants.layer
      ? ((constants.layer = 2), this.announceText('Layer 2: Smoothed line'))
      : 2 == constants.layer &&
        ((constants.layer = 1), this.announceText('Layer 1: Point'));
  }
  announceText(t) {
    constants.announceContainer.innerHTML = t;
  }
  UpdateBraillePos() {
    if ('barplot' == constants.chartType)
      constants.brailleInput.setSelectionRange(position.x, position.x);
    else if ('heatmap' == constants.chartType) {
      var t = position.y * (plot.num_cols + 1) + position.x;
      constants.brailleInput.setSelectionRange(t, t);
    } else if ('boxplot' == constants.chartType) {
      var t = 'vert' == constants.plotOrientation ? position.y : position.x,
        o = this.boxplotGridPlaceholders[t];
      let e = !1,
        n = 0;
      if (!constants.brailleData)
        throw 'Braille data not set up, cannot move cursor in braille, sorry.';
      for (let t = 0; t < constants.brailleData.length; t++) {
        if (
          'blank' != constants.brailleData[t].type &&
          resources.GetString(constants.brailleData[t].label) == o
        ) {
          e = !0;
          break;
        }
        n += constants.brailleData[t].numChars;
      }
      e || (n = 0), constants.brailleInput.setSelectionRange(n, n);
    } else
      'scatterplot' == constants.chartType &&
        constants.brailleInput.setSelectionRange(positionL1.x, positionL1.x);
  }
  displayValues(i) {
    let a = '',
      l = '';
    if ('barplot' == constants.chartType)
      (l =
        i.plotLegend.x +
        ' is ' +
        i.columnLabels[position.x] +
        ', ' +
        i.plotLegend.y +
        ' is ' +
        i.plotData[position.x]),
        'off' != constants.textMode &&
          ('terse' == constants.textMode
            ? (a +=
                '<p>' +
                i.columnLabels[position.x] +
                ' ' +
                i.plotData[position.x] +
                '</p>\n')
            : 'verbose' == constants.textMode && (a += '<p>' + l + '</p>\n'));
    else if ('heatmap' == constants.chartType)
      1 == constants.navigation
        ? (l +=
            i.x_group_label +
            ' ' +
            i.x_labels[position.x] +
            ', ' +
            i.y_group_label +
            ' ' +
            i.y_labels[position.y] +
            ', ' +
            i.box_label +
            ' is ')
        : (l +=
            i.y_group_label +
            ' ' +
            i.y_labels[position.y] +
            ', ' +
            i.x_group_label +
            ' ' +
            i.x_labels[position.x] +
            ', ' +
            i.box_label +
            ' is '),
        constants.hasRect && (l += i.plotData[2][position.y][position.x]),
        'off' != constants.textMode &&
          ('terse' == constants.textMode
            ? 1 == constants.navigation
              ? (a +=
                  '<p>' +
                  i.x_labels[position.x] +
                  ', ' +
                  i.plotData[2][position.y][position.x] +
                  '</p>\n')
              : (a +=
                  '<p>' +
                  i.y_labels[position.y] +
                  ', ' +
                  i.plotData[2][position.y][position.x] +
                  '</p>\n')
            : 'verbose' == constants.textMode && (a += '<p>' + l + '</p>\n'));
    else if ('boxplot' == constants.chartType) {
      let t = 0,
        e = 1,
        n = !1;
      var r = 'vert' == constants.plotOrientation ? position.x : position.y,
        p = 'vert' == constants.plotOrientation ? position.y : position.x;
      let o = '',
        s = '';
      ('lower_outlier' != i.plotData[r][p].label &&
        'upper_outlier' != i.plotData[r][p].label) ||
        (n = !0),
        'outlier' == i.plotData[r][p].type
          ? ((t = i.plotData[r][p].values.join(', ')),
            (e =
              0 < i.plotData[r][p].values.length
                ? i.plotData[r][p].values.length
                : 0))
          : 'blank' == i.plotData[r][p].type
          ? ((t = ''), n && (e = 0))
          : (t =
              'vert' == constants.plotOrientation
                ? i.plotData[r][p].y
                : i.plotData[r][p].x),
        constants.navigation
          ? i.x_group_label && (s += i.x_group_label)
          : constants.navigation || (i.y_group_label && (s += i.y_group_label)),
        constants.navigation
          ? i.x_labels[r]
            ? ((s += ' is '),
              (o += i.x_labels[r] + ', '),
              (s += i.x_labels[r] + ', '))
            : (s += ', ')
          : constants.navigation ||
            (i.y_labels[r]
              ? ((s += ' is '),
                (o += i.y_labels[r] + ', '),
                (s += i.y_labels[r] + ', '))
              : (s += ', ')),
        n && ((o += e + ' '), (s += e + ' ')),
        (s += resources.GetString(i.plotData[r][p].label)),
        1 == e ? (s += ' is ') : ((s += 's '), 1 < e && (s += ' are ')),
        (n ||
          (constants.navigation && 'horz' == constants.plotOrientation) ||
          (!constants.navigation && 'vert' == constants.plotOrientation)) &&
          ((o += resources.GetString(i.plotData[r][p].label)),
          1 != e && (o += 's'),
          (o += ' ')),
        'blank' != i.plotData[r][p].type || n
          ? ((o += t), (s += t))
          : ((o += 'empty'), (s += 'empty')),
        (l = s),
        'verbose' == constants.textMode
          ? (a = '<p>' + s + '</p>\n')
          : 'terse' == constants.textMode && (a = '<p>' + o + '</p>\n');
    } else
      'scatterplot' == constants.chartType &&
        (1 == constants.layer
          ? ((l +=
              i.x_group_label +
              ' ' +
              i.x[position.x] +
              ', ' +
              i.y_group_label +
              ' [' +
              i.y[position.x].join(', ') +
              ']'),
            'off' != constants.textMode &&
              ('terse' == constants.textMode
                ? (a +=
                    '<p>' +
                    i.x[position.x] +
                    ', [' +
                    i.y[position.x].join(', ') +
                    ']</p>\n')
                : constants.textMode))
          : 2 == constants.layer &&
            ((l +=
              i.x_group_label +
              ' ' +
              i.curveX[positionL1.x] +
              ', ' +
              i.y_group_label +
              ' ' +
              i.curvePoints[positionL1.x]),
            'off' != constants.textMode) &&
            ('terse' == constants.textMode
              ? (a += '<p>' + i.curvePoints[positionL1.x] + '<p>\n')
              : constants.textMode),
        'verbose' == constants.textMode) &&
        (a = '<p>' + l + '</p>\n');
    constants.infoDiv && (constants.infoDiv.innerHTML = a),
      constants.review &&
        (0 < a.length
          ? (constants.review.value = a.replace(/<[^>]*>?/gm, ''))
          : (constants.review.value = l));
  }
  displayXLabel(t) {
    let e = '';
    'barplot' == constants.chartType
      ? (e = t.plotLegend.x)
      : ('heatmap' != constants.chartType &&
          'boxplot' != constants.chartType &&
          'scatterplot' != constants.chartType) ||
        (e = t.x_group_label),
      'terse' == constants.textMode
        ? (constants.infoDiv.innerHTML = '<p>' + e + '<p>')
        : 'verbose' == constants.textMode &&
          (constants.infoDiv.innerHTML = '<p>x label is ' + e + '<p>');
  }
  displayYLabel(t) {
    let e = '';
    'barplot' == constants.chartType
      ? (e = t.plotLegend.y)
      : ('heatmap' != constants.chartType &&
          'boxplot' != constants.chartType &&
          'scatterplot' != constants.chartType) ||
        (e = t.y_group_label),
      'terse' == constants.textMode
        ? (constants.infoDiv.innerHTML = '<p>' + e + '<p>')
        : 'verbose' == constants.textMode &&
          (constants.infoDiv.innerHTML = '<p>y label is ' + e + '<p>');
  }
  displayTitle(t) {
    'terse' == constants.textMode
      ? '' != t.title
        ? (constants.infoDiv.innerHTML = '<p>' + t.title + '<p>')
        : (constants.infoDiv.innerHTML = '<p>Plot does not have a title.<p>')
      : 'verbose' == constants.textMode &&
        ('' != t.title
          ? (constants.infoDiv.innerHTML = '<p>Title is ' + t.title + '<p>')
          : (constants.infoDiv.innerHTML =
              '<p>Plot does not have a title.<p>'));
  }
  displayFill(t) {
    'terse' == constants.textMode
      ? 'heatmap' == constants.chartType &&
        (constants.infoDiv.innerHTML = '<p>' + t.box_label + '<p>')
      : 'verbose' == constants.textMode &&
        'heatmap' == constants.chartType &&
        (constants.infoDiv.innerHTML =
          '<p>Fill label is ' + t.box_label + '<p>');
  }
  SetBraille(l) {
    var r = [];
    if ('heatmap' == constants.chartType) {
      var t = (constants.maxY - constants.minY) / 3,
        n = constants.minY + t,
        o = n + t;
      for (let e = 0; e < l.y_coord.length; e++) {
        for (let t = 0; t < l.x_coord.length; t++)
          0 == l.values[e][t]
            ? r.push('⠀')
            : l.values[e][t] <= n
            ? r.push('⠤')
            : l.values[e][t] <= o
            ? r.push('⠒')
            : r.push('⠉');
        r.push('⠳');
      }
    } else if ('barplot' == constants.chartType) {
      var t = (constants.maxY - constants.minY) / 4,
        e = constants.minY + t,
        s = e + t,
        i = s + t;
      for (let t = 0; t < l.plotData.length; t++)
        l.plotData[t] <= e
          ? r.push('⣀')
          : l.plotData[t] <= s
          ? r.push('⠤')
          : l.plotData[t] <= i
          ? r.push('⠒')
          : r.push('⠉');
    } else if ('scatterplot' == constants.chartType) {
      var t = (l.curveMaxY - l.curveMinY) / 4,
        a = l.curveMinY + t,
        p = a + t,
        c = p + t,
        h = c + t;
      for (let t = 0; t < l.curvePoints.length; t++)
        l.curvePoints[t] <= a
          ? r.push('⣀')
          : l.curvePoints[t] <= p
          ? r.push('⠤')
          : l.curvePoints[t] <= c
          ? r.push('⠒')
          : l.curvePoints[t] <= h && r.push('⠉');
    } else if ('boxplot' == constants.chartType && -1 < position.y) {
      var d = [];
      let s = !0;
      var u = 'vert' == constants.plotOrientation ? position.x : position.y,
        y = 'vert' == constants.plotOrientation ? 'y' : 'x';
      for (let o = 0; o < l.plotData[u].length; o++) {
        var g = l.plotData[u][o];
        g.values &&
          constants.visualBraille &&
          (g.values = [...new Set(g.values)]);
        let t = null,
          e = null,
          n =
            (o < l.plotData[u].length - 1 && (t = l.plotData[u][o + 1]),
            0 < o && (e = l.plotData[u][o - 1]),
            {});
        if (0 == o) {
          let e = 0;
          for (let t = 0; t < l.plotData[u].length; t++)
            if (y in l.plotData[u][t]) {
              e = l.plotData[u][t][y];
              break;
            }
          n = {};
          var m =
            'vert' == constants.plotOrientation
              ? constants.minY
              : constants.minX;
          0 < e - m ? (n.length = e) : (n.length = 0),
            n.length < 0 && (n.length = 0),
            (n.type = 'blank'),
            (n.label = 'blank'),
            d.push(n);
        }
        if ('blank' != g.type)
          if ('outlier' == g.type) {
            s ||
              (((n = {}).length = g.values[0] - e[y]),
              (n.type = 'blank'),
              (n.label = 'blank'),
              d.push(n));
            for (var x = 0; x < g.values.length; x++)
              0 == x ||
                (((n = {}).length = g.values[x] - g.values[x - 1]),
                (n.type = 'blank'),
                (n.label = 'blank'),
                d.push(n)),
                ((n = { length: 0, type: 'outlier' }).label = g.label),
                d.push(n);
            s &&
              (((n = {}).length = t[y] - g.values[g.values.length - 1]),
              (n.type = 'blank'),
              (n.label = 'blank'),
              d.push(n));
          } else
            '50' == g.label
              ? (((n = { length: 0 }).type = g.type),
                (n.label = g.label),
                d.push(n),
                (s = !1))
              : ((n = {}),
                s ? (n.length = t[y] - g[y]) : (n.length = g[y] - e[y]),
                (n.type = g.type),
                (n.label = g.label),
                d.push(n));
        if (o == l.plotData[u].length - 1) {
          n = {};
          let e = 0;
          for (let t = 0; t < l.plotData[u].length; t++)
            'outlier' == g.type
              ? (e = 'y' == y ? g.yMax : g.xMax)
              : y in l.plotData[u][t] && (e = l.plotData[u][t][y]);
          (n.length = 'y' == y ? constants.maxY - e : constants.maxX - e),
            (n.type = 'blank'),
            (n.label = 'blank'),
            d.push(n);
        }
      }
      for (let t = 0; t < d.length; t++) d[t].length = Math.round(d[t].length);
      let e = -1,
        n = -1,
        o = -1,
        i = -1,
        a = 0;
      for (let t = 0; t < d.length; t++)
        'blank' != d[t].type && (0 < d[t].length || 'outlier' == d[t].type)
          ? ((d[t].numChars = 1), a++)
          : (d[t].numChars = 0),
          'min' == d[t].label && 0 < d[t].length && (e = t),
          'max' == d[t].label && 0 < d[t].length && (n = t),
          '25' == d[t].label && (o = t),
          '75' == d[t].label && (i = t),
          '50' == d[t].label && ((d[t].numChars = 2), a++);
      var t = ['25', '75'],
        t =
          (-1 < e &&
            -1 < n &&
            (t.push('min'), t.push('max'), d[e].length != d[n].length) &&
            (d[e].length > d[n].length ? d[e].numChars++ : d[n].numChars++,
            a++),
          d[o].length != d[i].length &&
            (d[o].length > d[i].length ? d[o].numChars++ : d[i].numChars++,
            a++),
          constants.brailleDisplayLength - a),
        v = this.AllocateCharacters(d, t);
      for (let t = 0; t < v.length; t++) v[t] && (d[t].numChars += v[t]);
      (constants.brailleData = d),
        5 < constants.debugLevel &&
          (console.log('plotData[i]', l.plotData[u]),
          console.log('brailleData', d));
      for (let n = 0; n < d.length; n++)
        for (let e = 0; e < d[n].numChars; e++) {
          let t = '⠀';
          'min' == d[n].label || 'max' == d[n].label
            ? (t = '⠒')
            : '25' == d[n].label || '75' == d[n].label
            ? (t = '⠿')
            : '50' == d[n].label
            ? (t = 0 == e ? '⠸' : '⠇')
            : 'outlier' == d[n].type && (t = '⠂'),
            r.push(t);
        }
    }
    (constants.brailleInput.value = r.join('')),
      (constants.brailleInput.value = r.join('')),
      5 < constants.debugLevel &&
        console.log('braille:', constants.brailleInput.value),
      this.UpdateBraillePos();
  }
  CharLenImpact(t) {
    return t.length / t.numChars;
  }
  AllocateCharacters(o, e) {
    let s = [],
      n = 0;
    for (let t = 0; t < o.length; t++) n += o[t].length;
    var t,
      i = ['lower_outlier', 'upper_outlier', '50'];
    for (let t = 0; t < o.length; t++)
      i.includes(o[t].label) || (s[t] = Math.round((o[t].length / n) * e));
    let a = e - s.reduce((t, e) => t + e, 0),
      l = o.length;
    for (; 0 !== a && 0 < l; ) {
      for (let t = 0; t < o.length; t++)
        i.includes(o[t].label) || (s[t] += Math.round((o[t].length / n) * a));
      (t = s.reduce((t, e) => t + e, 0)), (a = e - t), l--;
    }
    if (0 !== a) {
      var r = [];
      for (let t = 0; t < o.length; t++) r.push(t);
      r.sort((t, e) => s[t] - s[e]);
      let t = -1,
        e = (0 < a && (t = 1), 0),
        n = 3 * r.length;
      for (; 0 < a && 0 < n; )
        (s[r[e]] += t), (a += -t), (e += 1) >= r.length && (e = 0), (n += -1);
    }
    return s;
  }
}
class BarChart {
  constructor() {
    'elements' in maidr
      ? ((this.bars = maidr.elements), (constants.hasRect = 1))
      : ((this.bars = document.querySelectorAll('g[id^="geom_rect"] > rect')),
        (constants.hasRect = 0)),
      (this.columnLabels = []);
    let t = '',
      e = '';
    'axis' in maidr
      ? (maidr.axis.x && maidr.axis.x.label && (t = maidr.axis.x.label),
        maidr.axis.y && maidr.axis.y.label && (e = maidr.axis.y.label),
        maidr.axis.x &&
          maidr.axis.x.format &&
          (this.columnLabels = maidr.axis.x.format),
        maidr.axis.y &&
          maidr.axis.y.format &&
          (this.columnLabels = maidr.axis.y.format))
      : (document.querySelector('g[id^="xlab"] tspan') &&
          (t = document.querySelector('g[id^="xlab"] tspan').innerHTML),
        document.querySelector('g[id^="ylab"] tspan') &&
          (e = document.querySelector('g[id^="ylab"] tspan').innerHTML),
        (this.columnLabels = this.ParseInnerHTML(
          document.querySelectorAll(
            'g:not([id^="xlab"]):not([id^="ylab"]) > g > g > g > text[text-anchor="middle"]'
          )
        ))),
      (this.plotLegend = { x: t, y: e }),
      (this.title = ''),
      'title' in maidr
        ? (this.title = maidr.title)
        : document.querySelector('g[id^="plot.title..titleGrob"] tspan') &&
          ((this.title = document.querySelector(
            'g[id^="plot.title..titleGrob"] tspan'
          ).innerHTML),
          (this.title = this.title.replace('\n', '').replace(/ +(?= )/g, ''))),
      'array' == typeof maidr
        ? (this.plotData = maidr)
        : 'object' == typeof maidr &&
          'data' in maidr &&
          (this.plotData = maidr.data),
      this.SetMaxMin(),
      (this.autoplay = null);
  }
  SetMaxMin() {
    for (let t = 0; t < this.plotData.length; t++)
      0 == t
        ? ((constants.maxY = this.plotData[t]),
          (constants.minY = this.plotData[t]))
        : (this.plotData[t] > constants.maxY &&
            (constants.maxY = this.plotData[t]),
          this.plotData[t] < constants.minY &&
            (constants.minY = this.plotData[t]));
    constants.maxX = this.columnLabels.length;
  }
  GetLegendFromManualData() {
    var t = {};
    return (t.x = barplotLegend.x), (t.y = barplotLegend.y), t;
  }
  GetData() {
    var e = [];
    if (this.bars)
      for (let t = 0; t < this.bars.length; t++)
        e.push(this.bars[t].getAttribute('height'));
    return e;
  }
  GetColumns() {
    for (
      var t = [], e = document.querySelectorAll('tspan[dy="10"]'), n = 0;
      n < e.length;
      n++
    )
      t.push(e[n].innerHTML);
    return t;
  }
  GetLegend() {
    var t = {},
      e = document.querySelectorAll('tspan[dy="12"]');
    return (t.x = e[1].innerHTML), (t.y = e[0].innerHTML), t;
  }
  ParseInnerHTML(t) {
    for (var e = [], n = 0; n < t.length; n++) e.push(t[n].innerHTML);
    return e;
  }
  Select() {
    this.DeselectAll(),
      this.bars && (this.bars[position.x].style.fill = constants.colorSelected);
  }
  DeselectAll() {
    if (this.bars)
      for (let t = 0; t < this.bars.length; t++)
        this.bars[t].style.fill = constants.colorUnselected;
  }
}
class BoxPlot {
  constructor() {
    if (
      ((constants.plotId = 0),
      (constants.plotOrientation = 'horz'),
      'undefined' != typeof maidr &&
        (constants.plotOrientation = maidr.orientation),
      document.querySelector('g[id^="panel"] > g[id^="geom_boxplot.gTree"]') &&
        (constants.plotId = document
          .querySelector('g[id^="panel"] > g[id^="geom_boxplot.gTree"]')
          .getAttribute('id')),
      constants.manualData)
    ) {
      let t = '';
      'undefined' != typeof maidr && void 0 !== maidr.title
        ? (t = maidr.title)
        : document.querySelector('tspan[dy="9.45"]') &&
          (t = (t = document.querySelector('tspan[dy="9.45"]').innerHTML)
            .replace('\n', '')
            .replace(/ +(?= )/g, '')),
        (this.title = void 0 !== t && null != typeof t ? t : ''),
        'undefined' != typeof maidr
          ? (this.x_group_label = maidr.x_group_label)
          : (this.x_group_label = document.querySelector(
              'text:not([transform^="rotate"]) > tspan[dy="7.88"]'
            ).innerHTML),
        'undefined' != typeof maidr
          ? (this.y_group_label = maidr.y_group_label)
          : (this.y_group_label = document.querySelector(
              'text[transform^="rotate"] > tspan[dy="7.88"]'
            ).innerHTML);
      var e = [];
      if ('undefined' != typeof maidr)
        (this.x_labels = maidr.x_labels), (this.y_labels = maidr.y_labels);
      else {
        let t = '3.15';
        'vert' == constants.plotOrientation && (t = '6.3');
        var n = document.querySelectorAll('tspan[dy="' + t + '"]');
        for (let t = 0; t < n.length; t++) e.push(n[t].innerHTML.trim());
        'vert' == constants.plotOrientation
          ? ((this.x_labels = e), (this.y_labels = []))
          : ((this.x_labels = []), (this.y_labels = e));
      }
      'undefined' != typeof maidr
        ? (this.plotData = maidr.data)
        : (this.plotData = maidr);
    } else
      (this.x_group_label = document.getElementById(
        'GRID.text.199.1.1.tspan.1'
      ).innerHTML),
        (this.y_group_label = document.getElementById(
          'GRID.text.202.1.1.tspan.1'
        ).innerHTML),
        'vert' == constants.plotOrientation
          ? ((this.x_labels = this.GetLabels()), (this.y_labels = []))
          : ((this.x_labels = []), (this.y_labels = this.GetLabels())),
        (this.plotData = this.GetData());
    constants.plotId
      ? ((this.plotBounds = this.GetPlotBounds(constants.plotId)),
        (constants.hasRect = !0))
      : (constants.hasRect = !1),
      this.CleanData();
  }
  GetLabels() {
    var e = [],
      n = document.querySelectorAll('tspan[dy="5"]');
    for (let t = 0; t < n.length; t++) e.push(n[t].innerHTML.trim());
    return e;
  }
  CleanData() {
    if ('vert' == constants.plotOrientation) {
      constants.minY = 0;
      for (let e = (constants.maxY = 0); e < this.plotData.length; e++)
        for (let t = 0; t < this.plotData[e].length; t++) {
          var n = this.plotData[e][t];
          n.hasOwnProperty('y') &&
            (n.y < constants.minY && (constants.yMin = n.y),
            n.hasOwnProperty('yMax')
              ? n.yMax > constants.maxY && (constants.maxY = n.yMax)
              : n.y > constants.maxY && (constants.maxY = n.y)),
            n.hasOwnProperty('x') &&
              (n.x < constants.minX && (constants.minX = n.x),
              n.x > constants.maxX) &&
              (constants.maxX = n.x);
        }
    } else {
      constants.minX = 0;
      for (let e = (constants.maxX = 0); e < this.plotData.length; e++)
        for (let t = 0; t < this.plotData[e].length; t++) {
          var o = this.plotData[e][t];
          o.hasOwnProperty('x') &&
            (o.x < constants.minX && (constants.xMin = o.x),
            o.hasOwnProperty('xMax')
              ? o.xMax > constants.maxX && (constants.maxX = o.xMax)
              : o.x > constants.maxX && (constants.maxX = o.x)),
            o.hasOwnProperty('y') &&
              (o.y < constants.minY && (constants.minY = o.y),
              o.y > constants.maxY) &&
              (constants.maxY = o.y);
        }
    }
  }
  GetData() {
    let s = [];
    var e = document.getElementById(constants.plotId).children;
    for (let t = 0; t < e.length; t++) {
      var o = e[t].children;
      let n = [];
      for (let e = 0; e < o.length; e++) {
        var i = o[e].children;
        for (let t = 0; t < i.length; t++) {
          var a,
            l = i[t],
            r = this.GetBoxplotSegmentType(o[e].getAttribute('id')),
            p = this.GetBoxplotSegmentPoints(l, r);
          for (let t = 0; t < p.length; t += 2)
            ('whisker' == r && 0 == t && 'vert' == constants.plotOrientation) ||
              ((a = { x: Number(p[t]), y: Number(p[t + 1]), type: r }).y >
                constants.maxY && (constants.maxY = a.y),
              n.push(a));
        }
      }
      if (
        (n.sort(function (t, e) {
          return 'vert' == constants.plotOrientation ? t.y - e.y : t.x - e.x;
        }),
        'horz' == constants.plotOrientation)
      ) {
        var c = [];
        for (let t = 0; t < n.length; t++)
          0 < t && n[t - 1].x == n[t].x
            ? 'whisker' == n[t - 1].type && (c.splice(-1, 1), c.push(n[t]))
            : c.push(n[t]);
        n = c;
      }
      s.push(n);
    }
    s.sort(function (t, e) {
      return 'vert' == constants.plotOrientation
        ? t[0].x - e[0].x
        : t[0].y - e[0].y;
    });
    for (let o = 0; o < s.length; o++) {
      var h = s[o];
      let n = [];
      for (let e = 0; e < h.length + 1; e++) {
        let t = !1;
        if ((t = e == h.length || 'outlier' != h[e].type ? !0 : t)) {
          if (0 < n.length) {
            var d = [];
            for (let t = 0; t < n.length; t++)
              'vert' == constants.plotOrientation
                ? d.push(n[t].y)
                : d.push(n[t].x),
                0 < t && (s[o][e + t - n.length].type = 'delete');
            'vert' == constants.plotOrientation
              ? ((s[o][e - n.length].y = n[0].y),
                (s[o][e - n.length].yMax = n[n.length - 1].y))
              : ((s[o][e - n.length].x = n[0].x),
                (s[o][e - n.length].xMax = n[n.length - 1].x)),
              (s[o][e - n.length].values = d),
              (n = []);
          }
        } else n.push(h[e]);
      }
    }
    var n = [];
    for (let e = 0; e < s.length; e++) {
      n[e] = [];
      for (let t = 0; t < s[e].length; t++)
        'delete' != s[e][t].type && (n[e][t] = s[e][t]);
      n[e] = n[e].filter(function () {
        return !0;
      });
    }
    s = n;
    for (let n = 0; n < s.length; n++) {
      let e = 0;
      for (let t = 0; t < s[n].length; t++) {
        var u = s[n][t];
        'outlier' == u.type
          ? 0 < e
            ? (s[n][t].label = resources.GetString('upper_outlier'))
            : (s[n][t].label = resources.GetString('lower_outlier'))
          : 'whisker' == u.type
          ? 0 < e
            ? (s[n][t].label = resources.GetString('max'))
            : (s[n][t].label = resources.GetString('min'))
          : 'range' == u.type &&
            (0 == e
              ? (s[n][t].label = resources.GetString('25'))
              : 1 == e
              ? (s[n][t].label = resources.GetString('50'))
              : 2 == e && (s[n][t].label = resources.GetString('75')),
            e++);
      }
    }
    var y = this.GetAllSegmentTypes();
    for (let e = 0; e < s.length; e++)
      if (7 != s[e].length) {
        var g,
          m = [];
        for (let t = 0; t < s[e].length; t++) m.push(s[e][t].label);
        for (let t = 0; t < y.length; t++)
          m.includes(y[t]) ||
            ((g = { type: 'blank', label: y[t] }),
            s[e].splice(t, 0, g),
            m.splice(t, 0, y[t]));
      }
    for (let t = 0; t < s.length; t++)
      s[t][3].y = Math.round((s[t][2].y + s[t][4].y) / 2);
    return 1 < constants.debugLevel && console.log('plotData:', s), s;
  }
  GetPlotBounds(t) {
    var n = [],
      s = this.GetAllSegmentTypes(),
      i = /(?:\d+(?:\.\d*)?|\.\d+)/g,
      a = [],
      e = document.getElementById(constants.plotId).children;
    for (let t = 0; t < e.length; t++) {
      var o = {},
        l = e[t].children;
      for (let t = 0; t < l.length; t++)
        o[this.GetBoxplotSegmentType(l[t].getAttribute('id'))] = l[t];
      a.push(o);
    }
    for (let o = 0; o < a.length; o++) {
      var r = [],
        p = a[o].range.getBoundingClientRect(),
        c = a[o].range
          .querySelector('polyline[id^="GRID"]')
          .getAttribute('points')
          .match(i),
        h = a[o].range
          .querySelector('polygon[id^="geom_polygon"]')
          .getAttribute('points')
          .match(i);
      let t = 0,
        e =
          ((t =
            'vert' == constants.plotOrientation
              ? (c[1] - h[3]) / (h[1] - h[3])
              : (c[0] - h[2]) / (h[0] - h[2])),
          0);
      if (
        ((e = 'vert' == constants.plotOrientation ? p.height * t : p.width * t),
        (r[2] = this.convertBoundingClientRectToObj(p)),
        (r[2].label = s[2]),
        (r[2].type = 'range'),
        'vert' == constants.plotOrientation
          ? ((r[2].height = e),
            (r[2].top = r[2].bottom - e),
            (r[2].y = r[2].top))
          : (r[2].width = e),
        (r[3] = this.convertBoundingClientRectToObj(p)),
        (r[3].label = s[3]),
        (r[3].type = 'range'),
        'vert' == constants.plotOrientation
          ? ((r[3].height = 0),
            (r[3].top = p.bottom - e),
            (r[3].y = r[3].top),
            (r[3].bottom = r[3].top))
          : ((r[3].width = 0), (r[3].left = p.left + e)),
        (r[4] = this.convertBoundingClientRectToObj(p)),
        (r[4].label = s[4]),
        (r[4].type = 'range'),
        'vert' == constants.plotOrientation
          ? ((r[4].height = p.height - e), (r[4].bottom = r[3].top))
          : ((r[4].width = p.width - e), (r[4].left = r[3].left)),
        Object.hasOwn(a[o], 'whisker'))
      ) {
        c = a[o].whisker.getBoundingClientRect();
        let t = !1,
          e = !1;
        'vert' == constants.plotOrientation
          ? (c.bottom > p.bottom && (t = !0), c.top < p.top && (e = !0))
          : (c.left < p.left && (t = !0), c.right > p.right && (e = !0)),
          t
            ? ((r[1] = this.convertBoundingClientRectToObj(c)),
              (r[1].label = s[1]),
              (r[1].type = 'whisker'),
              'vert' == constants.plotOrientation
                ? ((r[1].top = r[2].bottom),
                  (r[1].y = r[1].top),
                  (r[1].height = r[1].bottom - r[1].top))
                : (r[1].width = r[2].left - r[1].left))
            : ((r[1] = {}), (r[1].label = s[1]), (r[1].type = 'blank')),
          e
            ? ((r[5] = this.convertBoundingClientRectToObj(c)),
              (r[5].label = s[5]),
              (r[5].type = 'whisker'),
              'vert' == constants.plotOrientation
                ? ((r[5].bottom = r[4].top),
                  (r[5].height = r[5].bottom - r[5].top))
                : ((r[5].left = r[4].right),
                  (r[5].x = r[4].right),
                  (r[5].width = r[5].right - r[5].left)))
            : ((r[5] = {}), (r[5].label = s[5]), (r[5].type = 'blank'));
      }
      if (Object.hasOwn(a[o], 'outlier')) {
        var d = a[o].outlier.children;
        let e = null,
          n = null;
        for (let t = 0; t < d.length; t++) {
          var u = d[t].getBoundingClientRect();
          'vert' == constants.plotOrientation
            ? u.y < p.y
              ? e
                ? (u.y < e.y && (e.y = u.y),
                  u.top < e.top && (e.top = u.top),
                  u.bottom > e.bottom && (e.bottom = u.bottom))
                : (e = this.convertBoundingClientRectToObj(u))
              : n
              ? (u.y < n.y && (n.y = u.y),
                u.top < n.top && (n.top = u.top),
                u.bottom > n.bottom && (n.bottom = u.bottom))
              : (n = this.convertBoundingClientRectToObj(u))
            : u.x > p.x
            ? e
              ? (u.x < e.x && (e.x = u.x),
                u.left < e.left && (e.left = u.left),
                u.right > e.right && (e.right = u.right))
              : (e = this.convertBoundingClientRectToObj(u))
            : n
            ? (u.x < n.x && (n.x = u.x),
              u.left < n.left && (n.left = u.left),
              u.right > n.right && (n.right = u.right))
            : (n = this.convertBoundingClientRectToObj(u));
        }
        n
          ? ((n.height = n.bottom - n.top),
            (n.width = n.right - n.left),
            (r[0] = this.convertBoundingClientRectToObj(n)),
            (r[0].label = s[0]),
            (r[0].type = 'outlier'))
          : ((r[0] = {}), (r[0].label = s[0]), (r[0].type = 'blank')),
          e
            ? ((e.height = e.bottom - e.top),
              (e.width = e.right - e.left),
              (r[6] = this.convertBoundingClientRectToObj(e)),
              (r[6].label = s[6]),
              (r[6].type = 'outlier'))
            : ((r[6] = {}), (r[6].label = s[6]), (r[6].type = 'blank'));
      } else
        (r[0] = {}),
          (r[0].label = s[0]),
          (r[0].type = 'blank'),
          (r[6] = {}),
          (r[6].label = s[6]),
          (r[6].type = 'blank');
      n.push(r);
    }
    return 5 < constants.debugLevel && console.log('plotBounds', n), n;
  }
  GetAllSegmentTypes() {
    return [
      resources.GetString('lower_outlier'),
      resources.GetString('min'),
      resources.GetString('25'),
      resources.GetString('50'),
      resources.GetString('75'),
      resources.GetString('max'),
      resources.GetString('upper_outlier'),
    ];
  }
  GetBoxplotSegmentType(t) {
    let e = 'outlier';
    return (
      t.includes('geom_crossbar')
        ? (e = 'range')
        : t.includes('GRID')
        ? (e = 'whisker')
        : t.includes('points') && (e = 'outlier'),
      e
    );
  }
  GetBoxplotSegmentPoints(t, e) {
    var n,
      o = /(?:\d+(?:\.\d*)?|\.\d+)/g,
      s = [];
    return (
      'range' == e
        ? ((n = t.children[0].getAttribute('points').match(o)),
          s.push(n[0], n[1]),
          n[0] != n[2] && s.push(n[2], n[3]))
        : 'outlier' == e
        ? s.push(t.getAttribute('x'), t.getAttribute('y'))
        : ((n = t.getAttribute('points').match(o)),
          'vert' == constants.plotOrientation
            ? n[1] != n[3] && s.push(n[0], n[1], n[2], n[3])
            : n[0] != n[2] && s.push(n[0], n[1], n[2], n[3])),
      s
    );
  }
  convertBoundingClientRectToObj(t) {
    return {
      top: t.top,
      right: t.right,
      bottom: t.bottom,
      left: t.left,
      width: t.width,
      height: t.height,
      x: t.x,
      y: t.y,
    };
  }
  PlayTones(t) {
    let e = null,
      n = null;
    constants.outlierInterval && clearInterval(constants.outlierInterval),
      (n =
        'vert' == constants.plotOrientation
          ? ((e = position.x), position.y)
          : ((e = position.y), position.x)),
      'blank' == plot.plotData[e][n].type
        ? t.PlayNull()
        : 'outlier' != plot.plotData[e][n].type
        ? t.playTone()
        : ((position.z = 0),
          (constants.outlierInterval = setInterval(function () {
            t.playTone(),
              (position.z += 1),
              (!Object.hasOwn(plot.plotData[e][n], 'values') ||
                position.z + 1 > plot.plotData[e][n].values.length) &&
                (clearInterval(constants.outlierInterval), (position.z = -1));
          }, constants.autoPlayOutlierRate)));
  }
}
class BoxplotRect {
  rectPadding = 15;
  rectStrokeWidth = 4;
  constructor() {
    (this.x1 = 0),
      (this.width = 0),
      (this.y1 = 0),
      (this.height = 0),
      (this.svgOffsetLeft = constants.svg.getBoundingClientRect().left),
      (this.svgOffsetTop = constants.svg.getBoundingClientRect().top);
  }
  UpdateRect() {
    document.getElementById('highlight_rect') &&
      document.getElementById('highlight_rect').remove();
    let t = position.x,
      e = position.y;
    var n;
    'vert' != constants.plotOrientation && ((t = position.y), (e = position.x)),
      (('vert' == constants.plotOrientation && -1 < position.y) ||
        ('horz' == constants.plotOrientation && -1 < position.x)) &&
        'blank' != (n = plot.plotBounds[t][e]).type &&
        ((this.x1 = n.left - this.rectPadding - this.svgOffsetLeft),
        (this.width = n.width + 2 * this.rectPadding),
        (this.y1 = n.top - this.rectPadding - this.svgOffsetTop),
        (this.height = n.height + 2 * this.rectPadding),
        5 < constants.debugLevel &&
          (console.log(
            'Point',
            plot.plotData[t][e].label,
            'bottom:',
            n.bottom,
            'top:',
            n.top
          ),
          console.log(
            'x1:',
            this.x1,
            'y1:',
            this.y1,
            'width:',
            this.width,
            'height:',
            this.height
          )),
        this.CreateRectDisplay());
  }
  CreateRectDisplay() {
    var t = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    t.setAttribute('id', 'highlight_rect'),
      t.setAttribute('x', this.x1),
      t.setAttribute('y', this.y1),
      t.setAttribute('width', this.width),
      t.setAttribute('height', this.height),
      t.setAttribute('stroke', constants.colorSelected),
      t.setAttribute('stroke-width', this.rectStrokeWidth),
      t.setAttribute('fill', 'none'),
      constants.svg.appendChild(t);
  }
}
class HeatMap {
  constructor() {
    'elements' in maidr
      ? ((this.plots = maidr.elements), (constants.hasRect = 1))
      : ((this.plots = document.querySelectorAll('g[id^="geom_rect"] > rect')),
        (constants.hasRect = 0)),
      (this.group_labels = this.getGroupLabels()),
      (this.x_labels = this.getXLabels()),
      (this.y_labels = this.getYLabels()),
      (this.title = this.getTitle()),
      (this.plotData = this.getHeatMapData()),
      this.updateConstants(),
      (this.x_coord = this.plotData[0]),
      (this.y_coord = this.plotData[1]),
      (this.values = this.plotData[2]),
      (this.num_rows = this.plotData[3]),
      (this.num_cols = this.plotData[4]),
      (this.x_group_label = this.group_labels[0].trim()),
      (this.y_group_label = this.group_labels[1].trim()),
      (this.box_label = this.group_labels[2].trim());
  }
  getHeatMapData() {
    var n = [],
      o = [];
    let s = [],
      i = [];
    if (constants.hasRect) {
      for (let t = 0; t < this.plots.length; t++)
        this.plots[t] &&
          (n.push(parseFloat(this.plots[t].getAttribute('x'))),
          o.push(parseFloat(this.plots[t].getAttribute('y'))));
      n.sort(function (t, e) {
        return t - e;
      }),
        o
          .sort(function (t, e) {
            return t - e;
          })
          .reverse(),
        (s = [...new Set(n)]),
        (i = [...new Set(o)]);
    }
    let a = 0,
      l = 0;
    (l = (
      'data' in maidr
        ? ((a = maidr.data.length), maidr.data[0])
        : ((a = i.length), s)
    ).length),
      a,
      l;
    let r = [];
    if ('data' in maidr) r = [...maidr.data];
    else {
      r = Array(a)
        .fill()
        .map(() => Array(l).fill(0));
      let t = 3 * Math.pow(255, 2),
        e = 0;
      for (var p = 0; p < this.plots.length; p++) {
        var c = s.indexOf(n[p]),
          h = i.indexOf(o[p]),
          d = this.getRGBNorm(p);
        (r[h][c] = d) < t && (t = d), d > e && (e = d);
      }
    }
    return [s, i, r, a, l];
  }
  updateConstants() {
    (constants.minX = 0),
      (constants.maxX = this.plotData[4]),
      (constants.minY = this.plotData[2][0][0]),
      (constants.maxY = this.plotData[2][0][0]);
    for (let e = 0; e < this.plotData[2].length; e++)
      for (let t = 0; t < this.plotData[2][e].length; t++)
        this.plotData[2][e][t] < constants.minY &&
          (constants.minY = this.plotData[2][e][t]),
          this.plotData[2][e][t] > constants.maxY &&
            (constants.maxY = this.plotData[2][e][t]);
  }
  getRGBNorm(t) {
    return this.plots[t]
      .getAttribute('fill')
      .slice(4, -1)
      .split(',')
      .map(function (t) {
        return Math.pow(t, 2);
      })
      .reduce(function (t, e) {
        return t + e;
      });
  }
  getGroupLabels() {
    let t = '',
      e = '',
      n = '';
    return (
      (t =
        'title' in maidr
          ? maidr.title
          : document.querySelector('g[id^="guide.title"] text > tspan')
              .innerHTML),
      'axes' in maidr
        ? ('x' in maidr.axes &&
            'label' in maidr.axes.x &&
            (e = maidr.axes.x.label),
          'y' in maidr.axes &&
            'label' in maidr.axes.y &&
            (n = maidr.axes.y.label))
        : ((e = document.querySelector('g[id^="xlab"] text > tspan').innerHTML),
          (n = document.querySelector('g[id^="ylab"] text > tspan').innerHTML)),
      [e, n, t]
    );
  }
  getXLabels() {
    if (!('axes' in maidr)) {
      var e = document.querySelectorAll('tspan[dy="10"]'),
        n = [];
      for (let t = 0; t < e.length; t++) n.push(e[t].innerHTML.trim());
      return n;
    }
    if ('x' in maidr.axes && 'format' in maidr.axes.x)
      return maidr.axes.x.format;
  }
  getYLabels() {
    if (!('axes' in maidr)) {
      var e = [],
        n = document.querySelectorAll('tspan[id^="GRID.text.19.1"]');
      for (let t = 0; t < n.length; t++) e.push(n[t].innerHTML.trim());
      return e.reverse();
    }
    if ('y' in maidr.axes && 'format' in maidr.axes.y)
      return maidr.axes.y.format;
  }
  getTitle() {
    var t;
    return 'title' in maidr
      ? maidr.title
      : ((t = document.querySelector(
          'g[id^="layout::title"] text > tspan'
        ).innerHTML),
        constants.manualData && void 0 !== t && null != typeof t ? t : '');
  }
}
class HeatMapRect {
  constructor() {
    constants.hasRect &&
      ((this.x = plot.x_coord[0]),
      (this.y = plot.y_coord[0]),
      (this.rectStrokeWidth = 4),
      (this.height = Math.abs(plot.y_coord[1] - plot.y_coord[0])));
  }
  UpdateRect() {
    (this.x = plot.x_coord[position.x]), (this.y = plot.y_coord[position.y]);
  }
  UpdateRectDisplay() {
    this.UpdateRect(),
      document.getElementById('highlight_rect') &&
        document.getElementById('highlight_rect').remove();
    var t = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    t.setAttribute('id', 'highlight_rect'),
      t.setAttribute('x', this.x),
      t.setAttribute(
        'y',
        constants.svg.getBoundingClientRect().height - this.height - this.y
      ),
      t.setAttribute('width', this.height),
      t.setAttribute('height', this.height),
      t.setAttribute('stroke', constants.colorSelected),
      t.setAttribute('stroke-width', this.rectStrokeWidth),
      t.setAttribute('fill', 'none'),
      constants.svg.appendChild(t);
  }
}
document.addEventListener('DOMContentLoaded', function (t) {});
class ScatterPlot {
  constructor() {
    'point_elements' in maidr
      ? (this.plotPoints = maidr.point_elements)
      : (this.plotPoints = document.querySelectorAll(
          '#' + constants.plotId.replaceAll('.', '\\.') + ' > use'
        )),
      (this.svgPointsX = this.GetSvgPointCoords()[0]),
      (this.svgPointsY = this.GetSvgPointCoords()[1]),
      (this.x = this.GetPointValues()[0]),
      (this.y = this.GetPointValues()[1]),
      (this.points_count = this.GetPointValues()[2]),
      (this.max_count = this.GetPointValues()[3]),
      constants.manualData
        ? (this.plotLine = maidr.smooth_elements)
        : (this.plotLine = document.querySelectorAll(
            '#' + 'GRID.polyline.13.1'.replaceAll('.', '\\.') + ' > polyline'
          )[0]),
      (this.svgLineX = this.GetSvgLineCoords()[0]),
      (this.svgLineY = this.GetSvgLineCoords()[1]),
      (this.curveX = this.GetSmoothCurvePoints()[0]),
      (this.curvePoints = this.GetSmoothCurvePoints()[1]),
      (this.curveMinY = Math.min(...this.curvePoints)),
      (this.curveMaxY = Math.max(...this.curvePoints)),
      (this.gradient = this.GetGradient()),
      (this.x_group_label = ''),
      (this.y_group_label = ''),
      (this.title = ''),
      'undefined' != typeof maidr &&
        ('axes' in maidr &&
          ('x' in maidr.axes && (this.x_group_label = maidr.axes.x.label),
          'y' in maidr.axes) &&
          (this.y_group_label = maidr.axes.y.label),
        'title' in maidr) &&
        (this.title = maidr.title);
  }
  GetSvgPointCoords() {
    let n = new Map();
    for (let t = 0; t < this.plotPoints.length; t++) {
      var e = parseFloat(this.plotPoints[t].getAttribute('x')),
        o = parseFloat(this.plotPoints[t].getAttribute('y'));
      n.has(e) ? n.get(e).add(o) : n.set(e, new Set([o]));
    }
    (n = new Map(
      [...n].sort(function (t, e) {
        return t[0] - e[0];
      })
    )).forEach(function (t, e) {
      n[e] = Array.from(t).sort(function (t, e) {
        return t - e;
      });
    });
    var s = [...n.keys()],
      i = [];
    for (let t = 0; t < s.length; t++) i.push(n[s[t]]);
    return [s, i];
  }
  GetPointValues() {
    let n = new Map();
    var e = [],
      o = [];
    for (let t = 0; t < maidr.data.data_point_layer.length; t++) {
      var s,
        i = maidr.data.data_point_layer[t].x,
        a = maidr.data.data_point_layer[t].y;
      e.push(i),
        o.push(a),
        n.has(i)
          ? n.get(i).has(a)
            ? (s = n.get(i)).set(a, s.get(a) + 1)
            : n.get(i).set(a, 1)
          : n.set(i, new Map([[a, 1]]));
    }
    (constants.minX = 0),
      (constants.maxX = [...new Set(e)].length),
      (constants.minY = Math.min(...o)),
      (constants.maxY = Math.max(...o)),
      (n = new Map(
        [...n].sort(function (t, e) {
          return t[0] - e[0];
        })
      )).forEach(function (t, e) {
        n[e] = Array.from(t).sort(function (t, e) {
          return t[0] - e[0];
        });
      });
    var t,
      l,
      r = [],
      p = [],
      c = [];
    for ([t, l] of n) {
      r.push(t);
      var h,
        d,
        u = [],
        y = [];
      for ([h, d] of l) u.push(h), y.push(d);
      p.push(u.sort()), c.push(y);
    }
    var g = Math.max(...c.map((t) => Math.max(...t)));
    return [r, p, c, g];
  }
  PlayTones(t) {
    constants.sepPlayId && constants.KillSepPlay(),
      1 == constants.layer
        ? ((position.z = 0),
          (constants.sepPlayId = setInterval(
            function () {
              t.playTone(),
                (position.z += 1),
                position.z + 1 > plot.y[position.x].length &&
                  (constants.KillSepPlay(), (position.z = -1));
            },
            'sep' == constants.sonifMode ? constants.autoPlayPointsRate : 0
          )))
        : 2 == constants.layer && t.playTone();
  }
  GetSvgLineCoords() {
    var e = this.plotLine.getAttribute('points').split(' '),
      n = [],
      o = [];
    for (let t = 0; t < e.length; t++) {
      var s = e[t].split(',');
      n.push(parseFloat(s[0])), o.push(parseFloat(s[1]));
    }
    return [n, o];
  }
  GetSmoothCurvePoints() {
    var e = [],
      n = [];
    for (let t = 0; t < maidr.data.data_smooth_layer.length; t++)
      e.push(maidr.data.data_smooth_layer[t].x),
        n.push(maidr.data.data_smooth_layer[t].y);
    return [e, n];
  }
  GetGradient() {
    var e = [];
    for (let t = 0; t < this.curvePoints.length - 1; t++) {
      var n = Math.abs(
        (this.curvePoints[t + 1] - this.curvePoints[t]) /
          (this.curveX[t + 1] - this.curveX[t])
      ).toFixed(3);
      e.push(n);
    }
    return e.push('end'), e;
  }
}
class Layer0Point {
  constructor() {
    (this.x = plot.svgPointsX[0]),
      (this.y = plot.svgPointsY[0]),
      (this.strokeWidth = 1.35);
  }
  async UpdatePoints() {
    await this.ClearPoints(),
      (this.x = plot.svgPointsX[position.x]),
      (this.y = plot.svgPointsY[position.x]);
  }
  async PrintPoints() {
    await this.ClearPoints(), await this.UpdatePoints();
    for (let t = 0; t < this.y.length; t++) {
      var e = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      e.setAttribute('class', 'highlight_point'),
        e.setAttribute('cx', this.x),
        e.setAttribute(
          'cy',
          constants.svg.getBoundingClientRect().height - this.y[t]
        ),
        e.setAttribute('r', 3.95),
        e.setAttribute('stroke', constants.colorSelected),
        e.setAttribute('stroke-width', this.strokeWidth),
        e.setAttribute('fill', constants.colorSelected),
        constants.svg.appendChild(e);
    }
  }
  async ClearPoints() {
    document.getElementById('highlight_point') &&
      document.getElementById('highlight_point').remove();
    var e = document.getElementsByClassName('highlight_point');
    for (let t = 0; t < e.length; t++)
      document.getElementsByClassName('highlight_point')[t].remove();
  }
  UpdatePointDisplay() {
    this.ClearPoints(), this.UpdatePoints(), this.PrintPoints();
  }
}
class Layer1Point {
  constructor() {
    (this.x = plot.svgLineX[0]),
      (this.y = plot.svgLineY[0]),
      (this.strokeWidth = 1.35);
  }
  async UpdatePoints() {
    await this.ClearPoints(),
      (this.x = plot.svgLineX[positionL1.x]),
      (this.y = plot.svgLineY[positionL1.x]);
  }
  async PrintPoints() {
    await this.ClearPoints(), await this.UpdatePoints();
    var t = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    t.setAttribute('id', 'highlight_point'),
      t.setAttribute('cx', this.x),
      t.setAttribute(
        'cy',
        constants.svg.getBoundingClientRect().height - this.y
      ),
      t.setAttribute('r', 3.95),
      t.setAttribute('stroke', constants.colorSelected),
      t.setAttribute('stroke-width', this.strokeWidth),
      t.setAttribute('fill', constants.colorSelected),
      constants.svg.appendChild(t);
  }
  async ClearPoints() {
    var e = document.getElementsByClassName('highlight_point');
    for (let t = 0; t < e.length; t++)
      document.getElementsByClassName('highlight_point')[t].remove();
    document.getElementById('highlight_point') &&
      document.getElementById('highlight_point').remove();
  }
  UpdatePointDisplay() {
    this.ClearPoints(), this.UpdatePoints(), this.PrintPoints();
  }
}
document.addEventListener('DOMContentLoaded', function (t) {
  if (
    ((window.constants = new Constants()),
    (window.resources = new Resources()),
    (window.menu = new Menu()),
    (window.tracker = new Tracker()),
    document.getElementById('download_data_trigger') &&
      document
        .getElementById('download_data_trigger')
        .addEventListener('click', function (t) {
          tracker.DownloadTrackerData();
        }),
    document.getElementById(constants.svg_container_id))
  ) {
    constants.PrepChartHelperComponents(),
      (window.review = new Review()),
      (window.display = new Display()),
      5 < constants.debugLevel &&
        setTimeout(function () {
          constants.svg.focus();
        }, 100),
      constants.svg_container &&
        constants.svg_container.addEventListener('keydown', function (t) {
          72 == t.which && menu.Toggle(!0);
        });
    var e = document.querySelectorAll('#close_menu, #menu .close');
    for (let t = 0; t < e.length; t++)
      e[t].addEventListener('click', function (t) {
        menu.Toggle(!1);
      });
    document
      .getElementById('save_and_close_menu')
      .addEventListener('click', function (t) {
        menu.SaveData(), menu.Toggle(!1);
      }),
      document.getElementById('menu').addEventListener('keydown', function (t) {
        27 == t.which && (menu.Toggle(!1), svg.focus());
      });
    let n = document.querySelectorAll(
      '#' +
        constants.svg_container_id +
        ' > svg, #' +
        constants.braille_input_id
    );
    for (let e = 0; e < n.length; e++)
      n[e].addEventListener('focus', function (t) {
        constants.nonMenuFocus = n[e];
      });
    document.addEventListener('keydown', function (t) {
      constants.isTracking && 121 != t.which && plot && tracker.LogEvent(t),
        (constants.isMac ? 91 == t.which || 93 == t.which : 17 == t.which) &&
          constants.KillAutoplay(),
        82 != t.which ||
          t.ctrlKey ||
          t.shiftKey ||
          t.altKey ||
          (t.preventDefault(),
          constants.review_container.classList.contains('hidden')
            ? review.ToggleReviewMode(!0)
            : review.ToggleReviewMode(!1));
    });
  }
  document.addEventListener('keydown', function (t) {
    ((116 == t.which && (constants.isMac ? t.metaKey : t.ctrlKey)) ||
      (82 == t.which &&
        t.shiftKey &&
        (constants.isMac ? t.metaKey : t.ctrlKey))) &&
      (t.preventDefault(), tracker.Delete(), location.reload(!0));
  });
}),
  document.addEventListener('DOMContentLoaded', function (t) {
    if (
      ('undefined' != typeof maidr &&
        'type' in maidr &&
        (constants.chartType = maidr.type),
      void 0 !== constants.chartType)
    )
      if ('barplot' == constants.chartType) {
        (window.position = new Position(-1, -1)),
          (window.plot = new BarChart());
        let o = new Audio(),
          s = '',
          i = 0,
          n = 0,
          a = !1;
        constants.svg_container.addEventListener('keydown', function (t) {
          let e = !1,
            n = !1;
          39 === t.which &&
            ((constants.isMac ? t.metaKey : t.ctrlKey)
              ? t.shiftKey
                ? (--position.x, d('right', position.x, plot.bars.length))
                : ((position.x = plot.bars.length - 1), (e = !0), (n = r()))
              : t.altKey && t.shiftKey && position.x != plot.bars.length - 1
              ? ((i = position.x),
                d('reverse-right', plot.bars.length, position.x))
              : ((position.x += 1), (e = !0), (n = r()))),
            37 === t.which &&
              ((constants.isMac ? t.metaKey : t.ctrlKey)
                ? t.shiftKey
                  ? ((position.x += 1), d('left', position.x, -1))
                  : ((position.x = 0), (e = !0), (n = r()))
                : t.altKey && t.shiftKey && 0 != position.x
                ? ((i = position.x), d('reverse-left', -1, position.x))
                : ((position.x += -1), (e = !0), (n = r()))),
            e && !n && p(),
            n && o.playEnd();
        }),
          constants.brailleInput.addEventListener('keydown', function (t) {
            let e = !1,
              n = !1;
            9 != t.which &&
              (39 == t.which
                ? (t.preventDefault(),
                  t.target.selectionStart > t.target.value.length - 2 ||
                    ((constants.isMac ? t.metaKey : t.ctrlKey)
                      ? t.shiftKey
                        ? (--position.x,
                          d('right', position.x, plot.bars.length))
                        : ((position.x = plot.bars.length - 1),
                          (e = !0),
                          (n = r()))
                      : t.altKey &&
                        t.shiftKey &&
                        position.x != plot.bars.length - 1
                      ? ((i = position.x),
                        d('reverse-right', plot.bars.length, position.x))
                      : ((position.x += 1), (e = !0), (n = r()))))
                : 37 == t.which
                ? (t.preventDefault(),
                  (constants.isMac ? t.metaKey : t.ctrlKey)
                    ? t.shiftKey
                      ? ((position.x += 1), d('left', position.x, -1))
                      : ((position.x = 0), (e = !0), (n = r()))
                    : t.altKey && t.shiftKey && 0 != position.x
                    ? ((i = position.x), d('reverse-left', -1, position.x))
                    : ((position.x += -1), (e = !0), (n = r())))
                : t.preventDefault()),
              constants.brailleInput.addEventListener('focusout', function (t) {
                display.toggleBrailleMode('off');
              }),
              e && !n && h(),
              n && o.playEnd();
          });
        var e = [constants.svg_container, constants.brailleInput];
        for (let t = 0; t < e.length; t++)
          e[t].addEventListener('keydown', function (t) {
            var e;
            66 == t.which && (display.toggleBrailleMode(), t.preventDefault()),
              84 == t.which &&
                ((e = window.performance.now() - n),
                !a || e > constants.keypressInterval) &&
                display.toggleTextMode(),
              83 == t.which && display.toggleSonificationMode(),
              32 === t.which && p();
          });
        function r() {
          let t = !1;
          return (
            constants.hasRect &&
              (position.x < 0 && ((position.x = 0), (t = !0)),
              position.x > plot.bars.length - 1) &&
              ((position.x = plot.bars.length - 1), (t = !0)),
            t
          );
        }
        function p() {
          constants.showDisplay && display.displayValues(plot),
            constants.showRect && constants.hasRect && plot.Select(),
            'off' != constants.sonifMode && o.playTone();
        }
        function c() {
          constants.showDisplayInAutoplay && display.displayValues(plot),
            constants.showRect && constants.hasRect && plot.Select(),
            'off' != constants.sonifMode && o.playTone(),
            'off' != constants.brailleMode && display.UpdateBraillePos(plot);
        }
        function h() {
          constants.showDisplayInBraille && display.displayValues(plot),
            constants.showRect && constants.hasRect && plot.Select(),
            'off' != constants.sonifMode && o.playTone(),
            display.UpdateBraillePos(plot);
        }
        function d(t, e, n) {
          let o = 'left' != (s = t) && 'reverse-right' != t ? 1 : -1;
          null != constants.autoplayId && constants.KillAutoplay(),
            ('reverse-right' != t && 'reverse-left' != t) || (position.x = e),
            (constants.autoplayId = setInterval(function () {
              (position.x += o),
                (position.x < 0 || plot.bars.length - 1 < position.x
                  ? (constants.KillAutoplay(), r)
                  : (position.x == n && constants.KillAutoplay(), c))();
            }, constants.autoPlayRate));
        }
        document.addEventListener('keydown', function (t) {
          var e;
          (constants.isMac ? t.metaKey : t.ctrlKey) &&
            (36 == t.which
              ? ((position.x = 0), h())
              : 35 == t.which && ((position.x = plot.bars.length - 1), h())),
            (a =
              a &&
              (88 == t.which
                ? ((e = window.performance.now() - n),
                  a &&
                    e <= constants.keypressInterval &&
                    display.displayXLabel(plot),
                  !1)
                : 89 == t.which
                ? ((e = window.performance.now() - n),
                  a &&
                    e <= constants.keypressInterval &&
                    display.displayYLabel(plot),
                  !1)
                : 84 == t.which
                ? ((e = window.performance.now() - n),
                  a &&
                    e <= constants.keypressInterval &&
                    display.displayTitle(plot),
                  !1)
                : 76 == t.which && ((n = window.performance.now()), !0))),
            76 == t.which && ((n = window.performance.now()), (a = !0)),
            190 == t.which &&
              (constants.SpeedUp(), null != constants.autoplayId) &&
              (constants.KillAutoplay(),
              'reverse-left' == s
                ? d('right', position.x, i)
                : 'reverse-right' == s
                ? d('left', position.x, i)
                : d(s, position.x, i)),
            188 == t.which &&
              (constants.SpeedDown(), null != constants.autoplayId) &&
              (constants.KillAutoplay(),
              'reverse-left' == s
                ? d('right', position.x, i)
                : 'reverse-right' == s
                ? d('left', position.x, i)
                : d(s, position.x, i));
        });
      } else if ('boxplot' == constants.chartType) {
        (constants.plotId = 'geom_boxplot.gTree.78.1'),
          (window.plot = new BoxPlot()),
          (constants.chartType = 'boxplot'),
          'vert' == constants.plotOrientation
            ? (window.position = new Position(0, plot.plotData[0].length - 1))
            : (window.position = new Position(-1, plot.plotData.length));
        let t = new BoxplotRect(),
          s = new Audio(),
          i = '',
          a = 0,
          l = 0,
          n = 0,
          o = !1;
        constants.svg_container.addEventListener('keydown', function (t) {
          let e = !1,
            n = !1;
          39 === t.which &&
            ((constants.isMac ? t.metaKey : t.ctrlKey)
              ? t.shiftKey
                ? 'vert' == constants.plotOrientation
                  ? d('right', position.x, plot.plotData.length - 1)
                  : d('right', position.x, plot.plotData[position.y].length)
                : ((n = r()),
                  'vert' == constants.plotOrientation
                    ? (position.x = plot.plotData.length - 1)
                    : (position.x = plot.plotData[position.y].length - 1),
                  (e = !0),
                  (n = r()))
              : 'vert' == constants.plotOrientation
              ? t.altKey && t.shiftKey && plot.plotData.length - 1 != position.x
                ? ((a = position.y),
                  d('reverse-right', plot.plotData.length - 1, position.x))
                : (-1 == position.x &&
                    position.y == plot.plotData[position.x].length &&
                    --position.y,
                  (position.x += 1),
                  (e = !0),
                  (n = r()))
              : t.altKey &&
                t.shiftKey &&
                plot.plotData[position.y].length - 1 != position.x
              ? ((l = position.x),
                d(
                  'reverse-right',
                  plot.plotData[position.y].length - 1,
                  position.x
                ))
              : (-1 == position.x &&
                  position.y == plot.plotData.length &&
                  --position.y,
                (position.x += 1),
                (e = !0),
                (n = r())),
            (constants.navigation = 1)),
            37 === t.which &&
              ((constants.isMac ? t.metaKey : t.ctrlKey)
                ? t.shiftKey
                  ? d('left', position.x, -1)
                  : ((position.x = 0), (e = !0), (n = r()))
                : t.altKey && t.shiftKey && 0 < position.x
                ? ('vert' == constants.plotOrientation
                    ? (a = position.y)
                    : (l = position.x),
                  d('reverse-left', 0, position.x))
                : ((position.x += -1), (e = !0), (n = r())),
              (constants.navigation = 1)),
            38 === t.which &&
              (position.y,
              (constants.isMac ? t.metaKey : t.ctrlKey)
                ? t.shiftKey
                  ? 'vert' == constants.plotOrientation
                    ? d('up', position.y, plot.plotData[position.x].length)
                    : d('up', position.y, plot.plotData.length)
                  : ('vert' == constants.plotOrientation
                      ? (position.y = plot.plotData[position.x].length - 1)
                      : (position.y = plot.plotData.length - 1),
                    (e = !0),
                    (n = r()))
                : 'vert' == constants.plotOrientation
                ? t.altKey &&
                  t.shiftKey &&
                  position.y != plot.plotData[position.x].length - 1
                  ? ((a = position.y),
                    d(
                      'reverse-up',
                      plot.plotData[position.x].length - 1,
                      position.y
                    ))
                  : ((position.y += 1), (e = !0), (n = r()))
                : t.altKey &&
                  t.shiftKey &&
                  position.y != plot.plotData.length - 1
                ? ((l = position.x),
                  d('reverse-up', plot.plotData.length - 1, position.y))
                : ((position.y += 1), (e = !0), (n = r())),
              (constants.navigation = 0)),
            40 === t.which &&
              (position.y,
              (constants.isMac ? t.metaKey : t.ctrlKey)
                ? t.shiftKey
                  ? d('down', position.y, -1)
                  : ((position.y = 0), (e = !0), (n = r()))
                : t.altKey && t.shiftKey && 0 != position.y
                ? ('vert' == constants.plotOrientation
                    ? (a = position.y)
                    : (l = position.x),
                  d('reverse-down', 0, position.y))
                : ('vert' == constants.plotOrientation
                    ? -1 == position.x &&
                      position.y == plot.plotData[position.x].length &&
                      (position.x += 1)
                    : -1 == position.x &&
                      position.y == plot.plotData.length &&
                      (position.x += 1),
                  (position.y += -1),
                  (e = !0),
                  (n = r())),
              (constants.navigation = 0)),
            e && !n && p(),
            n && s.playEnd();
        }),
          constants.brailleInput.addEventListener('keydown', function (t) {
            let e = !1,
              n = !1,
              o = !1;
            9 != t.which &&
              (39 == t.which
                ? (t.preventDefault(),
                  (constants.isMac ? t.metaKey : t.ctrlKey)
                    ? t.shiftKey
                      ? 'vert' == constants.plotOrientation
                        ? d('right', position.x, plot.plotData.length - 1)
                        : d(
                            'right',
                            position.x,
                            plot.plotData[position.y].length
                          )
                      : ('vert' == constants.plotOrientation
                          ? (position.x = plot.plotData.length - 1)
                          : (position.x = plot.plotData[position.y].length - 1),
                        (e = !0),
                        (o = r()))
                    : 'vert' == constants.plotOrientation
                    ? t.altKey &&
                      t.shiftKey &&
                      plot.plotData.length - 1 != position.x
                      ? ((a = position.y),
                        d(
                          'reverse-right',
                          plot.plotData.length - 1,
                          position.x
                        ))
                      : (-1 == position.x &&
                          position.y == plot.plotData[position.x].length &&
                          --position.y,
                        (position.x += 1),
                        (e = !0),
                        (o = r()))
                    : t.altKey &&
                      t.shiftKey &&
                      plot.plotData[position.y].length - 1 != position.x
                    ? ((l = position.x),
                      d(
                        'reverse-right',
                        plot.plotData[position.y].length - 1,
                        position.x
                      ))
                    : (-1 == position.x &&
                        position.y == plot.plotData.length &&
                        --position.y,
                      (position.x += 1),
                      (e = !0),
                      (o = r())),
                  (n = !0),
                  (constants.navigation = 1))
                : 37 == t.which
                ? (t.preventDefault(),
                  (constants.isMac ? t.metaKey : t.ctrlKey)
                    ? t.shiftKey
                      ? d('left', position.x, -1)
                      : ((position.x = 0), (e = !0), (o = r()))
                    : t.altKey && t.shiftKey && 0 < position.x
                    ? ('vert' == constants.plotOrientation
                        ? (a = position.y)
                        : (l = position.x),
                      d('reverse-left', 0, position.x))
                    : ((position.x += -1), (e = !0), (o = r())),
                  (n = !0),
                  (constants.navigation = 1))
                : 38 === t.which
                ? (position.y,
                  (constants.isMac ? t.metaKey : t.ctrlKey)
                    ? t.shiftKey
                      ? 'vert' == constants.plotOrientation
                        ? (position.x < 0 && (position.x = 0),
                          d('up', position.y, plot.plotData[position.x].length))
                        : d('up', position.y, plot.plotData.length)
                      : (e =
                          ('vert' == constants.plotOrientation
                            ? (position.y =
                                plot.plotData[position.x].length - 1)
                            : (position.y = plot.plotData.length - 1),
                          !0))
                    : 'vert' == constants.plotOrientation
                    ? t.altKey &&
                      t.shiftKey &&
                      position.y != plot.plotData[position.x].length - 1
                      ? ((lasY = position.y),
                        d(
                          'reverse-up',
                          plot.plotData[position.x].length - 1,
                          position.y
                        ))
                      : ((position.y += 1), (e = !0), (o = r()))
                    : t.altKey &&
                      t.shiftKey &&
                      position.y != plot.plotData.length - 1
                    ? ((l = position.x),
                      d('reverse-up', plot.plotData.length - 1, position.y))
                    : ((position.y += 1), (e = !0), (o = r())),
                  'vert' != constants.plotOrientation && (n = !0),
                  (constants.navigation = 0))
                : 40 === t.which
                ? (position.y,
                  (constants.isMac ? t.metaKey : t.ctrlKey)
                    ? t.shiftKey
                      ? d('down', position.y, -1)
                      : ((position.y = 0), (e = !0), (o = r()))
                    : t.altKey && t.shiftKey && 0 != position.y
                    ? ('vert' == constants.plotOrientation
                        ? (a = position.y)
                        : (l = position.x),
                      d('reverse-down', 0, position.y))
                    : ('vert' == constants.plotOrientation
                        ? -1 == position.x &&
                          position.y == plot.plotData[position.x].length &&
                          (position.x += 1)
                        : -1 == position.x &&
                          position.y == plot.plotData.length &&
                          (position.x += 1),
                      (position.y += -1),
                      (e = !0),
                      (o = r())),
                  (constants.navigation = 0),
                  'vert' != constants.plotOrientation && (n = !0),
                  (constants.navigation = 0))
                : t.preventDefault()),
              e && !o && (n && display.SetBraille(plot), setTimeout(h, 50)),
              o && s.playEnd(),
              constants.brailleInput.addEventListener('focusout', function (t) {
                display.toggleBrailleMode('off');
              });
          });
        var u = [constants.svg_container, constants.brailleInput];
        for (let t = 0; t < u.length; t++)
          u[t].addEventListener('keydown', function (t) {
            var e;
            66 == t.which && (display.toggleBrailleMode(), t.preventDefault()),
              84 == t.which &&
                ((e = window.performance.now() - n),
                !o || e > constants.keypressInterval) &&
                display.toggleTextMode(),
              83 == t.which && display.toggleSonificationMode(),
              32 === t.which && p();
          });
        function p() {
          constants.showDisplay && display.displayValues(plot),
            constants.showRect && constants.hasRect && t.UpdateRect(),
            'off' != constants.sonifMode && plot.PlayTones(s);
        }
        function c() {
          constants.showDisplayInAutoplay && display.displayValues(plot),
            constants.showRect && constants.hasRect && t.UpdateRect(),
            'off' != constants.sonifMode && plot.PlayTones(s),
            'off' != constants.brailleMode && display.UpdateBraillePos(plot);
        }
        function h() {
          constants.showDisplayInBraille && display.displayValues(plot),
            constants.showRect && constants.hasRect && t.UpdateRect(),
            'off' != constants.sonifMode && plot.PlayTones(s),
            display.UpdateBraillePos(plot);
        }
        function r() {
          let t = !1;
          return (
            'vert' == constants.plotOrientation
              ? (position.y < 0 && ((position.y = 0), (t = !0)),
                position.x < 0 && ((position.x = 0), (t = !0)),
                position.x > plot.plotData.length - 1 &&
                  ((position.x = plot.plotData.length - 1), (t = !0)),
                position.y > plot.plotData[position.x].length - 1 &&
                  ((position.y = plot.plotData[position.x].length - 1),
                  (t = !0)))
              : (position.x < 0 && ((position.x = 0), (t = !0)),
                position.y < 0 && ((position.y = 0), (t = !0)),
                position.y > plot.plotData.length - 1 &&
                  ((position.y = plot.plotData.length - 1), (t = !0)),
                position.x > plot.plotData[position.y].length - 1 &&
                  ((position.x = plot.plotData[position.y].length - 1),
                  (t = !0))),
            t
          );
        }
        function d(e, t, n) {
          let o =
            'left' != (i = e) &&
            'down' != e &&
            'reverse-right' != e &&
            'reverse-up' != e
              ? 1
              : -1;
          null != constants.autoplayId && constants.KillAutoplay(),
            'reverse-left' == e || 'reverse-right' == e
              ? (position.x = t)
              : ('reverse-up' != e && 'reverse-down' != e) || (position.y = t),
            0 < constants.debugLevel && console.log('starting autoplay', e),
            c(),
            (constants.autoplayId = setInterval(function () {
              let t = !1;
              'left' == e || 'right' == e || 'up' == e || 'down' == e
                ? ((position.x < 1 && 'left' == e) ||
                    ('vert' == constants.plotOrientation &&
                      'up' == e &&
                      position.y > plot.plotData[position.x].length - 2) ||
                    ('horz' == constants.plotOrientation &&
                      'up' == e &&
                      position.y > plot.plotData.length - 2) ||
                    ('horz' == constants.plotOrientation &&
                      'right' == e &&
                      position.x > plot.plotData[position.y].length - 2) ||
                    ('vert' == constants.plotOrientation &&
                      'right' == e &&
                      position.x > plot.plotData.length - 2) ||
                    ('horz' == constants.plotOrientation &&
                      'down' == e &&
                      position.y < 1) ||
                    ('vert' == constants.plotOrientation &&
                      'down' == e &&
                      position.y < 1)) &&
                  (t = !0)
                : (('reverse-left' == e && position.x >= n) ||
                    ('reverse-right' == e && position.x <= n) ||
                    ('reverse-up' == e && position.y <= n) ||
                    ('reverse-down' == e && position.y >= n)) &&
                  (t = !0),
                t
                  ? constants.KillAutoplay()
                  : ('left' == e ||
                    'right' == e ||
                    'reverse-left' == e ||
                    'reverse-right' == e
                      ? (position.x += o)
                      : (position.y += o),
                    c()),
                5 < constants.debugLevel &&
                  console.log('autoplay pos', position);
            }, constants.autoPlayRate));
        }
        document.addEventListener('keydown', function (t) {
          var e;
          (constants.isMac ? t.metaKey : t.ctrlKey) &&
            (36 == t.which
              ? ((position.x = 0), (position.y = plot.plotData.length - 1), h())
              : 35 == t.which &&
                ((position.x = plot.plotData[0].length - 1),
                (position.y = 0),
                h())),
            (o =
              o &&
              (88 == t.which
                ? ((e = window.performance.now() - n),
                  o &&
                    e <= constants.keypressInterval &&
                    display.displayXLabel(plot),
                  !1)
                : 89 == t.which
                ? ((e = window.performance.now() - n),
                  o &&
                    e <= constants.keypressInterval &&
                    display.displayYLabel(plot),
                  !1)
                : 84 == t.which
                ? ((e = window.performance.now() - n),
                  o &&
                    e <= constants.keypressInterval &&
                    display.displayTitle(plot),
                  !1)
                : 76 == t.which && ((n = window.performance.now()), !0))),
            76 == t.which && ((n = window.performance.now()), (o = !0)),
            190 == t.which &&
              (constants.SpeedUp(), null != constants.autoplayId) &&
              (constants.KillAutoplay(),
              'reverse-left' == i
                ? 'vert' == constants.plotOrientation
                  ? d('right', position.y, a)
                  : d('right', position.x, l)
                : 'reverse-right' == i
                ? 'vert' == constants.plotOrientation
                  ? d('left', position.y, a)
                  : d('left', position.x, l)
                : 'reverse-up' == i
                ? 'vert' == constants.plotOrientation
                  ? d('down', position.y, a)
                  : d('down', position.x, l)
                : 'reverse-down' == i
                ? 'vert' == constants.plotOrientation
                  ? d('up', position.y, a)
                  : d('up', position.x, l)
                : 'vert' == constants.plotOrientation
                ? d(i, position.y, a)
                : d(i, position.x, l)),
            188 == t.which &&
              (constants.SpeedDown(), null != constants.autoplayId) &&
              (constants.KillAutoplay(),
              'reverse-left' == i
                ? 'vert' == constants.plotOrientation
                  ? d('right', position.y, a)
                  : d('right', position.x, l)
                : 'reverse-right' == i
                ? 'vert' == constants.plotOrientation
                  ? d('left', position.y, a)
                  : d('left', position.x, l)
                : 'reverse-up' == i
                ? 'vert' == constants.plotOrientation
                  ? d('down', position.y, a)
                  : d('down', position.x, l)
                : 'reverse-down' == i
                ? 'vert' == constants.plotOrientation
                  ? d('up', position.y, a)
                  : d('up', position.x, l)
                : 'vert' == constants.plotOrientation
                ? d(i, position.y, a)
                : d(i, position.x, l));
        });
      } else if ('heatmap' == constants.chartType) {
        (constants.plotId = 'geom_rect.rect.2.1'),
          (window.position = new Position(-1, -1)),
          (window.plot = new HeatMap()),
          (constants.chartType = 'heatmap');
        let t = new HeatMapRect(),
          s = new Audio(),
          i = '',
          a = 0,
          n = 0,
          o = !1;
        constants.svg_container.addEventListener('keydown', function (t) {
          let e = !1,
            n = !1;
          39 === t.which &&
            ((constants.isMac ? t.metaKey : t.ctrlKey)
              ? t.shiftKey
                ? (--position.x, d('right', position.x, plot.num_cols))
                : ((position.x = plot.num_cols - 1), (e = !0))
              : t.altKey && t.shiftKey && position.x != plot.num_cols - 1
              ? ((a = position.x),
                d('reverse-right', plot.num_cols, position.x))
              : (-1 == position.x && -1 == position.y && (position.y += 1),
                (position.x += 1),
                (e = !0),
                (n = r())),
            (constants.navigation = 1)),
            37 === t.which &&
              ((constants.isMac ? t.metaKey : t.ctrlKey)
                ? t.shiftKey
                  ? ((position.x += 1), d('left', position.x, -1))
                  : ((position.x = 0), (e = !0))
                : t.altKey && t.shiftKey && 0 != position.x
                ? ((a = position.x), d('reverse-left', -1, position.x))
                : (--position.x, (e = !0), (n = r())),
              (constants.navigation = 1)),
            38 === t.which &&
              ((constants.isMac ? t.metaKey : t.ctrlKey)
                ? t.shiftKey
                  ? ((position.y += 1), d('up', position.y, -1))
                  : ((position.y = 0), (e = !0))
                : t.altKey && t.shiftKey && 0 != position.y
                ? ((a = position.x), d('reverse-up', -1, position.y))
                : (--position.y, (e = !0), (n = r())),
              (constants.navigation = 0)),
            40 === t.which &&
              ((constants.isMac ? t.metaKey : t.ctrlKey)
                ? t.shiftKey
                  ? (--position.y, d('down', position.y, plot.num_rows))
                  : ((position.y = plot.num_rows - 1), (e = !0))
                : t.altKey && t.shiftKey && position.y != plot.num_rows - 1
                ? ((a = position.x),
                  d('reverse-down', plot.num_rows, position.y))
                : (-1 == position.x && -1 == position.y && (position.x += 1),
                  (position.y += 1),
                  (e = !0),
                  (n = r())),
              (constants.navigation = 0)),
            e && !n && p(),
            n && s.playEnd();
        }),
          constants.brailleInput.addEventListener('keydown', function (t) {
            let e = !1,
              n = !1;
            var o;
            9 != t.which &&
              (39 == t.which
                ? t.target.selectionStart > t.target.value.length - 3 ||
                  '⠳' ==
                    t.target.value.substring(
                      t.target.selectionStart + 1,
                      t.target.selectionStart + 2
                    )
                  ? t.preventDefault()
                  : ((constants.isMac ? t.metaKey : t.ctrlKey)
                      ? (-1 == position.x &&
                          -1 == position.y &&
                          ((position.x += 1), (position.y += 1)),
                        t.shiftKey
                          ? (--position.x,
                            d('right', position.x, plot.num_cols))
                          : ((position.x = plot.num_cols - 1), (e = !0)))
                      : t.altKey &&
                        t.shiftKey &&
                        position.x != plot.num_cols - 1
                      ? ((a = position.x),
                        d('reverse-right', plot.num_cols, position.x))
                      : (-1 == position.x &&
                          -1 == position.y &&
                          (position.y += 1),
                        (position.x += 1),
                        (e = !0),
                        (n = r())),
                    (o = position.y * (plot.num_cols + 1) + position.x),
                    t.target.setSelectionRange(o, o),
                    t.preventDefault(),
                    (constants.navigation = 1))
                : 37 == t.which
                ? 0 == t.target.selectionStart ||
                  '⠳' ==
                    t.target.value.substring(
                      t.target.selectionStart - 1,
                      t.target.selectionStart
                    )
                  ? t.preventDefault()
                  : ((constants.isMac ? t.metaKey : t.ctrlKey)
                      ? t.shiftKey
                        ? ((position.x += 1), d('left', position.x, -1))
                        : ((position.x = 0), (e = !0))
                      : t.altKey && t.shiftKey && 0 != position.x
                      ? ((a = position.x), d('reverse-left', -1, position.x))
                      : ((position.x += -1), (e = !0), (n = r())),
                    (o = position.y * (plot.num_cols + 1) + position.x),
                    t.target.setSelectionRange(o, o),
                    t.preventDefault(),
                    (constants.navigation = 1))
                : 40 == t.which
                ? position.y + 1 == plot.num_rows
                  ? t.preventDefault()
                  : ((constants.isMac ? t.metaKey : t.ctrlKey)
                      ? (-1 == position.x &&
                          -1 == position.y &&
                          ((position.x += 1), (position.y += 1)),
                        t.shiftKey
                          ? (--position.y, d('down', position.y, plot.num_rows))
                          : ((position.y = plot.num_rows - 1), (e = !0)))
                      : t.altKey &&
                        t.shiftKey &&
                        position.y != plot.num_rows - 1
                      ? ((a = position.x),
                        d('reverse-down', plot.num_rows, position.y))
                      : (-1 == position.x &&
                          -1 == position.y &&
                          (position.x += 1),
                        (position.y += 1),
                        (e = !0),
                        (n = r())),
                    (o = position.y * (plot.num_cols + 1) + position.x),
                    t.target.setSelectionRange(o, o),
                    t.preventDefault(),
                    (constants.navigation = 0))
                : 38 != t.which ||
                  t.target.selectionStart - plot.num_cols - 1 < 0
                ? t.preventDefault()
                : ((constants.isMac ? t.metaKey : t.ctrlKey)
                    ? t.shiftKey
                      ? ((position.y += 1), d('up', position.y, -1))
                      : ((position.y = 0), (e = !0))
                    : t.altKey && t.shiftKey && 0 != position.y
                    ? ((a = position.x), d('reverse-up', -1, position.y))
                    : ((position.y += -1), (e = !0), (n = r())),
                  (o = position.y * (plot.num_cols + 1) + position.x),
                  t.target.setSelectionRange(o, o),
                  t.preventDefault(),
                  (constants.navigation = 0))),
              constants.brailleInput.addEventListener('focusout', function (t) {
                display.toggleBrailleMode('off');
              }),
              e && !n && h(),
              n && s.playEnd();
          });
        var l = [constants.svg_container, constants.brailleInput];
        for (let t = 0; t < l.length; t++)
          l[t].addEventListener('keydown', function (t) {
            var e;
            66 == t.which && (display.toggleBrailleMode(), t.preventDefault()),
              84 == t.which &&
                ((e = window.performance.now() - n),
                !o || e > constants.keypressInterval) &&
                display.toggleTextMode(),
              83 == t.which && display.toggleSonificationMode(),
              32 === t.which && p();
          });
        function r() {
          let t = !1;
          return (
            position.x < 0 && ((position.x = 0), (t = !0)),
            position.x > plot.num_cols - 1 &&
              ((position.x = plot.num_cols - 1), (t = !0)),
            position.y < 0 && ((position.y = 0), (t = !0)),
            position.y > plot.num_rows - 1 &&
              ((position.y = plot.num_rows - 1), (t = !0)),
            t
          );
        }
        function p() {
          constants.showDisplay && display.displayValues(plot),
            constants.showRect && constants.hasRect && t.UpdateRectDisplay(),
            'off' != constants.sonifMode && s.playTone();
        }
        function c() {
          constants.showDisplayInAutoplay && display.displayValues(plot),
            constants.showRect && constants.hasRect && t.UpdateRectDisplay(),
            'off' != constants.sonifMode && s.playTone(),
            'off' != constants.brailleMode && display.UpdateBraillePos(plot);
        }
        function h() {
          constants.showDisplayInBraille && display.displayValues(plot),
            constants.showRect && constants.hasRect && t.UpdateRectDisplay(),
            'off' != constants.sonifMode && s.playTone(),
            display.UpdateBraillePos(plot);
        }
        function d(t, e, n) {
          let o =
            'left' != (i = t) &&
            'up' != t &&
            'reverse-right' != t &&
            'reverse-down' != t
              ? 1
              : -1;
          null != constants.autoplayId && constants.KillAutoplay(),
            'reverse-left' == t || 'reverse-right' == t
              ? (position.x = e)
              : ('reverse-up' != t && 'reverse-down' != t) || (position.y = e),
            (constants.autoplayId = setInterval(function () {
              ('left' == t ||
                'right' == t ||
                'reverse-left' == t ||
                'reverse-right' == t
                ? ((position.x += o),
                  position.x < 0 || plot.num_cols - 1 < position.x
                    ? (constants.KillAutoplay(), r)
                    : (position.x == n && constants.KillAutoplay(), c))
                : ((position.y += o),
                  position.y < 0 || plot.num_rows - 1 < position.y
                    ? (constants.KillAutoplay(), r)
                    : (position.y == n && constants.KillAutoplay(), c)))();
            }, constants.autoPlayRate));
        }
        document.addEventListener('keydown', function (t) {
          var e;
          (constants.isMac ? t.metaKey : t.ctrlKey) &&
            (36 == t.which
              ? ((position.x = 0), (position.y = 0), h())
              : 35 == t.which &&
                ((position.x = plot.num_cols - 1),
                (position.y = plot.num_rows - 1),
                h())),
            (o =
              o &&
              (88 == t.which
                ? ((e = window.performance.now() - n),
                  o &&
                    e <= constants.keypressInterval &&
                    display.displayXLabel(plot),
                  !1)
                : 89 == t.which
                ? ((e = window.performance.now() - n),
                  o &&
                    e <= constants.keypressInterval &&
                    display.displayYLabel(plot),
                  !1)
                : 84 == t.which
                ? ((e = window.performance.now() - n),
                  o &&
                    e <= constants.keypressInterval &&
                    display.displayTitle(plot),
                  !1)
                : 70 == t.which
                ? ((e = window.performance.now() - n),
                  o &&
                    e <= constants.keypressInterval &&
                    display.displayFill(plot),
                  !1)
                : 76 == t.which && ((n = window.performance.now()), !0))),
            76 == t.which && ((n = window.performance.now()), (o = !0)),
            190 == t.which &&
              (constants.SpeedUp(), null != constants.autoplayId) &&
              (constants.KillAutoplay(),
              'reverse-left' == i
                ? d('right', position.x, a)
                : 'reverse-right' == i
                ? d('left', position.x, a)
                : 'reverse-up' == i
                ? d('down', position.x, a)
                : 'reverse-down' == i
                ? d('up', position.x, a)
                : d(i, position.x, a)),
            188 == t.which &&
              (constants.SpeedDown(), null != constants.autoplayId) &&
              (constants.KillAutoplay(),
              'reverse-left' == i
                ? d('right', position.x, a)
                : 'reverse-right' == i
                ? d('left', position.x, a)
                : 'reverse-up' == i
                ? d('down', position.x, a)
                : 'reverse-down' == i
                ? d('up', position.x, a)
                : d(i, position.x, a));
        });
      } else if (
        'scatterplot' == constants.chartType ||
        constants.chartType.includes('scatterplot')
      ) {
        (constants.plotId = 'geom_point.points.12.1'),
          (window.position = new Position(-1, -1)),
          (window.plot = new ScatterPlot()),
          (constants.chartType = 'scatterplot');
        let a = new Audio(),
          t = new Layer0Point(),
          e = new Layer1Point(),
          l = '',
          o = 0,
          s = 0,
          n = 0,
          i = !1;
        (window.positionL1 = new Position(s, s)),
          constants.svg_container.addEventListener('keydown', function (t) {
            let e = !1,
              n = !1;
            1 == constants.layer
              ? (39 === t.which &&
                  ((constants.isMac ? t.metaKey : t.ctrlKey)
                    ? t.shiftKey
                      ? (--position.x,
                        d('outward_right', position.x, plot.x.length))
                      : ((position.x = plot.x.length - 1), (e = !0), (n = r()))
                    : t.altKey && t.shiftKey && position.x != plot.x.length - 1
                    ? ((o = position.x),
                      d('inward_right', plot.x.length, position.x))
                    : ((position.x += 1), (e = !0), (n = r()))),
                37 === t.which &&
                  ((constants.isMac ? t.metaKey : t.ctrlKey)
                    ? t.shiftKey
                      ? ((position.x += 1), d('outward_left', position.x, -1))
                      : ((position.x = 0), (e = !0), (n = r()))
                    : t.altKey && t.shiftKey && 0 != position.x
                    ? ((o = position.x), d('inward_left', -1, position.x))
                    : (--position.x, (e = !0), (n = r()))))
              : 2 == constants.layer &&
                ((positionL1.x = s),
                39 == t.which &&
                  t.shiftKey &&
                  ((constants.isMac ? t.metaKey : t.ctrlKey) &&
                  'off' != constants.sonifMode
                    ? g('outward_right')
                    : t.altKey &&
                      'off' != constants.sonifMode &&
                      g('inward_right')),
                37 == t.which) &&
                t.shiftKey &&
                ((constants.isMac ? t.metaKey : t.ctrlKey) &&
                'off' != constants.sonifMode
                  ? g('outward_left')
                  : t.altKey &&
                    'off' != constants.sonifMode &&
                    g('inward_left')),
              e && 1 == constants.layer && !n && p(),
              n && a.playEnd();
          }),
          constants.brailleInput.addEventListener('keydown', function (t) {
            let e = !1,
              n = !1;
            9 != t.which &&
              (2 == constants.layer
                ? (r(),
                  9 != t.which &&
                    (39 == t.which
                      ? (t.preventDefault(),
                        constants.brailleInput.setSelectionRange(
                          positionL1.x,
                          positionL1.x
                        ),
                        t.target.selectionStart > t.target.value.length - 2
                          ? t.preventDefault()
                          : (constants.isMac ? t.metaKey : t.ctrlKey)
                          ? t.shiftKey
                            ? (--positionL1.x,
                              d(
                                'outward_right',
                                positionL1.x,
                                plot.curvePoints.length
                              ))
                            : ((positionL1.x = plot.curvePoints.length - 1),
                              (e = !0),
                              (n = r()))
                          : t.altKey &&
                            t.shiftKey &&
                            positionL1.x != plot.curvePoints.length - 1
                          ? ((s = positionL1.x),
                            d(
                              'inward_right',
                              plot.curvePoints.length,
                              positionL1.x
                            ))
                          : ((positionL1.x += 1), (e = !0), (n = r())))
                      : 37 == t.which
                      ? (t.preventDefault(),
                        (constants.isMac ? t.metaKey : t.ctrlKey)
                          ? t.shiftKey
                            ? ((positionL1.x += 1),
                              d('outward_left', positionL1.x, -1))
                            : ((positionL1.x = 0), (e = !0), (n = r()))
                          : t.altKey && t.shiftKey && 0 != positionL1.x
                          ? d('inward_left', -1, positionL1.x)
                          : (--positionL1.x, (e = !0), (n = r())))
                      : t.preventDefault()))
                : t.preventDefault()),
              constants.brailleInput.addEventListener('focusout', function (t) {
                display.toggleBrailleMode('off');
              }),
              (s = positionL1.x),
              e && !n && h(),
              n && a.playEnd();
          });
        var y = [constants.svg_container, constants.brailleInput];
        for (let t = 0; t < y.length; t++)
          y[t].addEventListener('keydown', function (t) {
            var e;
            66 == t.which && (display.toggleBrailleMode(), t.preventDefault()),
              84 == t.which &&
                ((e = window.performance.now() - n),
                !i || e > constants.keypressInterval) &&
                display.toggleTextMode(),
              83 == t.which && display.toggleSonificationMode(),
              34 == t.which &&
                2 == constants.layer &&
                'off' == constants.brailleMode &&
                ((s = positionL1.x), display.toggleLayerMode()),
              33 == t.which &&
                1 == constants.layer &&
                'off' == constants.brailleMode &&
                display.toggleLayerMode(),
              32 === t.which && p();
          });
        function r() {
          let t = !1;
          return (
            1 == constants.layer
              ? (position.x < 0 && ((position.x = 0), (t = !0)),
                position.x > plot.x.length - 1 &&
                  ((position.x = plot.x.length - 1), (t = !0)))
              : 2 == constants.layer &&
                (positionL1.x < 0 && ((positionL1.x = 0), (t = !0)),
                positionL1.x > plot.curvePoints.length - 1) &&
                ((positionL1.x = plot.curvePoints.length - 1), (t = !0)),
            t
          );
        }
        function p() {
          constants.showDisplay && display.displayValues(plot),
            constants.showRect && t.UpdatePointDisplay(),
            'off' != constants.sonifMode && plot.PlayTones(a);
        }
        function c() {
          constants.showDisplayInAutoplay && display.displayValues(plot),
            constants.showRect &&
              (1 == constants.layer ? t : e).UpdatePointDisplay(),
            'off' != constants.sonifMode && plot.PlayTones(a),
            'off' != constants.brailleMode && display.UpdateBraillePos(plot);
        }
        function h() {
          constants.showDisplayInBraille && display.displayValues(plot),
            constants.showRect && e.UpdatePointDisplay(),
            'off' != constants.sonifMode && plot.PlayTones(a),
            display.UpdateBraillePos(plot);
        }
        function d(t, e, n) {
          let o = 'outward_left' != (l = t) && 'inward_right' != t ? 1 : -1;
          constants.autoplayId && constants.KillAutoplay(),
            constants.isSmoothAutoplay && a.KillSmooth(),
            ('inward_left' != t && 'inward_right' != t) ||
              ((position.x = e), (position.L1x = e)),
            1 == constants.layer
              ? (constants.autoplayId = setInterval(function () {
                  (position.x += o),
                    (position.x < 0 || position.x > plot.y.length - 1
                      ? (constants.KillAutoplay(), r)
                      : (position.x == n && constants.KillAutoplay(), c))();
                }, constants.autoPlayRate))
              : 2 == constants.layer &&
                (constants.autoplayId = setInterval(function () {
                  (positionL1.x += o),
                    (positionL1.x < 0 ||
                      positionL1.x > plot.curvePoints.length - 1
                      ? (constants.KillAutoplay(), r)
                      : (positionL1.x == n && constants.KillAutoplay(), c))();
                }, constants.autoPlayRate));
        }
        function g(t) {
          l = t;
          var e = [];
          let n = [];
          var o = a.SlideBetween(
              positionL1.x,
              0,
              plot.curvePoints.length - 1,
              -1,
              1
            ),
            s = positionL1.x < 0 ? 0 : positionL1.x;
          let i = 0;
          if ('outward_right' == t) {
            for (let t = s; t < plot.curvePoints.length; t++)
              e.push(
                a.SlideBetween(
                  plot.curvePoints[t],
                  plot.curveMinY,
                  plot.curveMaxY,
                  constants.MIN_FREQUENCY,
                  constants.MAX_FREQUENCY
                )
              );
            (n = [o, 1]),
              (i =
                (Math.abs(plot.curvePoints.length - s) /
                  plot.curvePoints.length) *
                3);
          } else if ('outward_left' == t) {
            for (let t = s; 0 <= t; t--)
              e.push(
                a.SlideBetween(
                  plot.curvePoints[t],
                  plot.curveMinY,
                  plot.curveMaxY,
                  constants.MIN_FREQUENCY,
                  constants.MAX_FREQUENCY
                )
              );
            (n = [o, -1]), (i = (Math.abs(s) / plot.curvePoints.length) * 3);
          } else if ('inward_right' == t) {
            for (let t = plot.curvePoints.length - 1; t >= s; t--)
              e.push(
                a.SlideBetween(
                  plot.curvePoints[t],
                  plot.curveMinY,
                  plot.curveMaxY,
                  constants.MIN_FREQUENCY,
                  constants.MAX_FREQUENCY
                )
              );
            (n = [1, o]),
              (i =
                (Math.abs(plot.curvePoints.length - s) /
                  plot.curvePoints.length) *
                3);
          } else if ('inward_left' == t) {
            for (let t = 0; t <= s; t++)
              e.push(
                a.SlideBetween(
                  plot.curvePoints[t],
                  plot.curveMinY,
                  plot.curveMaxY,
                  constants.MIN_FREQUENCY,
                  constants.MAX_FREQUENCY
                )
              );
            (n = [-1, o]), (i = (Math.abs(s) / plot.curvePoints.length) * 3);
          }
          constants.isSmoothAutoplay && a.KillSmooth(),
            a.playSmooth(e, i, n, constants.vol, 'sine');
        }
        document.addEventListener('keydown', function (t) {
          var e;
          (constants.isMac ? t.metaKey : t.ctrlKey) &&
            (36 == t.which
              ? 1 == constants.layer
                ? ((position.x = 0),
                  p(),
                  constants.brailleInput.setSelectionRange(0, 0))
                : 2 == constants.layer && ((positionL1.x = 0), h())
              : 35 == t.which &&
                (1 == constants.layer
                  ? ((position.x = plot.y.length - 1),
                    p(),
                    constants.brailleInput.setSelectionRange(
                      plot.curvePoints.length - 1,
                      plot.curvePoints.length - 1
                    ))
                  : 2 == constants.layer &&
                    ((positionL1.x = plot.curvePoints.length - 1), h())),
            t.shiftKey || a.KillSmooth()),
            (i =
              i &&
              (88 == t.which
                ? ((e = window.performance.now() - n),
                  i &&
                    e <= constants.keypressInterval &&
                    display.displayXLabel(plot),
                  !1)
                : 89 == t.which
                ? ((e = window.performance.now() - n),
                  i &&
                    e <= constants.keypressInterval &&
                    display.displayYLabel(plot),
                  !1)
                : 84 == t.which
                ? ((e = window.performance.now() - n),
                  i &&
                    e <= constants.keypressInterval &&
                    display.displayTitle(plot),
                  !1)
                : 76 == t.which && ((n = window.performance.now()), !0))),
            76 == t.which && ((n = window.performance.now()), (i = !0)),
            190 == t.which &&
              (constants.SpeedUp(), null != constants.autoplayId) &&
              (constants.KillAutoplay(),
              a.KillSmooth(),
              'inward_left' == l
                ? 1 == constants.layer
                  ? d('outward_right', position.x, o)
                  : 2 == constants.layer && d('outward_right', positionL1.x, s)
                : 'inward_right' == l
                ? 1 == constants.layer
                  ? d('outward_left', position.x, o)
                  : 2 == constants.layer && d('outward_left', positionL1.x, s)
                : 1 == constants.layer
                ? d(l, position.x, o)
                : 2 == constants.layer && d(l, positionL1.x, s)),
            188 == t.which &&
              (constants.SpeedDown(), null != constants.autoplayId) &&
              (constants.KillAutoplay(),
              a.KillSmooth(),
              'inward_left' == l
                ? 1 == constants.layer
                  ? d('outward_right', position.x, o)
                  : 2 == constants.layer && d('outward_right', positionL1.x, s)
                : 'inward_right' == l
                ? 1 == constants.layer
                  ? d('outward_left', position.x, o)
                  : 2 == constants.layer && d('outward_left', positionL1.x, s)
                : 1 == constants.layer
                ? d(l, position.x, o)
                : 2 == constants.layer && d(l, positionL1.x, s));
        });
      }
  });
